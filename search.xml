<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RxJava2 源码解析：Observable 系列]]></title>
    <url>%2F2017%2F05%2F17%2FRxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自 RxJava 在2016年11月12日正式发布2.0.1版本以来也有一段事件了，其内部实现也逐渐趋于稳定，截止到笔者开始这篇文章时已更新到2.1.0。 Version 2.1.0 is the next minor release of the 2.x era and contains the standardization of many experimental API additions from the past half a year since version 2.0.0. Therefore, the following components are now considered stable and will be supported throughout the rest of the life of RxJava 2.x. 从版本信息来看应该是比较稳定的版本，所以这篇文章将会使用 2.1.0 版本的代码进行分析。 RxJava2.0 是遵循 Reactive Streams Specification 的规范完成的，跟 RxJava1.x 相比，RxJava2 的变化还是很大的，最明显的就是接口的变化和对背压支持的完善，更详细的区别可以阅读官方文档 What’s-different-in-2.0。 由于 RxJava1.x 中背压的支持是在后面加入的,对背压的支持不是很完善，并不是所有的操作符都能正确响应下游的 request 请求。而且背压的实现机制上，RxJava1.x 采用的是中游阻塞的方式，RxJava2 中则不存在中游阻塞的过程，完全由下游自己决定去多少。因此 RxJava2 将背压的支持从原来的 Observable 中抽取出来，RxJava2 中的 Observable 不再支持背压，而 Flowable 支持非阻塞式的背压，并且 Flowable 中所有操作符强制支持背压。 因此对于 RxJava2 的源码分析将分为两篇，这一篇主要分析 Observable 及相关操作符。下一篇主要分析 Flowable 及相关操作符还有背压的实现原理。 我们还是从最简单的使用场景为例子来分析 12345678910111213141516171819202122232425262728293031323334Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; observableEmitter) throws Exception &#123; observableEmitter.onNext(1); observableEmitter.onComplete(); &#125; &#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(@NonNull Integer integer) throws Exception &#123; return integer.toString(); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable disposable) &#123; Log.d(TAG, &quot;onSubscribe&quot;); &#125; @Override public void onNext(String s) &#123; Log.d(TAG, &quot;&quot; + s); &#125; @Override public void onError(Throwable throwable) &#123; Log.d(TAG, &quot;onError&quot;); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;onComplete&quot;); &#125; &#125;); 这个例子非常简单，但是已经涵盖了 Observable 和 Observer 的创建、数据的转换(map)、线程调度(subscribeOn/observeOn) 这些常见的场景。 在这个过程中应该关注以下几点： Observable 怎么发送数据到 Observer 怎么对数据流进行变换 线程的调度 那么下面就开始进行分析。 create1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, &quot;source is null&quot;); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; Observable 的 create() 方法接收一个 ObservableOnSubscribe 参数，也就是例子中创建的匿名类。ObservableOnSubscribe 接口中只有一个 subscribe() 方法，该方法传进来一个 ObservableEmitter 实例，使用onNext()、onError() 和 onComplete() 就能向 Obsever 发送数据了，其实这些方法最终会调用 Observer 的相应方法。 回到 create() 方法，程序用 ObservableOnSubscribe 实例来创建了一个 ObservableCreate 对象，然后作为参数来调用 RxJavaPlugins.onAssembly() 方法。 onAssembly() 方法里面调用了相关的 hook 方法，在正常流程中可以当作这个方法什么也没做，只是简单的返回传入的对象。后面见到的 RxJavaPlugins 的相关方法也是如此。 那么主要的逻辑就是在 ObservableCreate 对象的创建上了 1234567public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; final ObservableOnSubscribe&lt;T&gt; source; public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123; this.source = source; &#125;&#125; ObservableCreate 的构造函数非常简单，只是简单保存了我们创建的 ObservableOnSubscribe 对象。这里是适配器模式的体现，用 ObservableCreate 将 ObservableOnSubscribe 适配成 Observable，以方便后面的链式调用。 creat() 方法的流程就分析到这里，目前我们得到了一个 ObservableCreate 对象，里面封装了我们创建的 ObservableOnSubscribe 实例。里面的一些逻辑要等到它被订阅之后才会调用。 mapObservableCreate 继承了 Observable，所以这里的 map() 方法调用的就是父类 Observable 的 map() 方法。 1234public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) &#123; ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;); return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));&#125; map() 方法的作用是对于 Observable 发送的每一个数据项，都是用一个用户指定的方法将数据项转型，是 Observable 发送的是转型后的数据项。 所以 map() 方法接收一个 Function 对象作为参数，用于执行其 apply() 方法进行数据项转型，在例子中我们只是简单地将整型转成字符串。 回到 map() 方法本身，其实就是用 ObservableCreate 实例和 Function 对象作为参数来创建一个 ObservableMap 然后返回，依然是 Observable 类型。我们来看一下它的构造方法 12345678910111213141516171819202122public final class ObservableMap&lt;T, U&gt; extends AbstractObservableWithUpstream&lt;T, U&gt; &#123; final Function&lt;? super T, ? extends U&gt; function; public ObservableMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends U&gt; function) &#123; super(source); this.function = function; &#125;&#125;///具有可消耗事件源源的操作符的基类,也是一个Observableabstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; AbstractObservableWithUpstream(ObservableSource&lt;T&gt; source) &#123; this.source = source; &#125; @Override public final ObservableSource&lt;T&gt; source() &#123; return source; &#125;&#125; 其实就是简单的赋值操作。ObservableMap 继承了 AbstractObservableWithUpstream ，表示该实例也是一个 Observable，但是它本身并不产生数据，由它的上游即内部保存的 source Observable 来发射数据。 到现在为止还没有什么实质逻辑，因为订阅还没有开始。目前我们得到了一个 ObservableMap 对象，里面封装了 ObservableCreate 实例和 Function 对象。 接下来就是线程调度了。 subscribeOn1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; subscribeOn 操作符用于指定上游执行的线程,通过一个 Scheduler 实例来指定。在例子中我们指定的是 IO 线程，那么该实例就是 IoScheduler。 Schedulers 类中已经预定义了一系列 Schedulers 供我们选择，满足了大部分的使用场景 123456789101112131415161718public final class Schedulers &#123; static final class SingleHolder &#123; static final Scheduler DEFAULT = new SingleScheduler(); &#125; static final class ComputationHolder &#123; static final Scheduler DEFAULT = new ComputationScheduler(); &#125; static final class IoHolder &#123; static final Scheduler DEFAULT = new IoScheduler(); &#125; static final class NewThreadHolder &#123; static final Scheduler DEFAULT = new NewThreadScheduler(); &#125;&#125; 回到 subscribeOn() 方法，方法内部使用 ObservableMap 和 Scheduler 实例作为构造参数来创建了一个 ObservableSubscribeOn 然后返回。那么我们来看看它的构造方法 123456789public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; final Scheduler scheduler; public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; ///保存ObservableMap super(source); this.scheduler = scheduler; &#125;&#125; 跟 ObservableMap 的构造方法还是一样的套路，简单的属性赋值，在 ObservableMap 上再封装一层 ObservableSubscribeOn。 可以预见 observeOn 操作符也是一样的逻辑。 observeOn12345678910public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; ///默认errordelay=false,bufferSize=128 return observeOn(scheduler, false, bufferSize());&#125;public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;); ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; observeOn() 方法也是接收一个 Scheduler 对象作为参数，这里具体是 HandlerScheduler 对象。方法内部调用了另一个重载方法，指定 errordelay=false 和 bufferSize=128，errordelay 表示当发生异常时是否马上结束事件流，bufferSize 表示缓存队列的大小。 重载方法中将一系列值作为参数用来创建一个 ObservableObserveOn 对象然后返回。它的构造方法 1234567891011public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; final Scheduler scheduler; final boolean delayError; final int bufferSize; public ObservableObserveOn(ObservableSource&lt;T&gt; source, Scheduler scheduler, boolean delayError, int bufferSize) &#123; super(source); this.scheduler = scheduler; this.delayError = delayError; this.bufferSize = bufferSize; &#125;&#125; 保存了 ObservableSubscribeOn 实例和一些参数。 现在我们得到了一个 ObservableObserveOn 对象，Observable 类型，但是它是由 ObservableOnSubscribe -&gt; ObservableCreate -&gt; ObservableMap -&gt; ObservableSubscribeOn -&gt; ObservableObserveOn 这样层层封装而来，跟调用的操作符顺序对应。目前它已经涵盖了数据发射、数据处理、线程调度这些流程了，只要调用 subscribe 就能触发这些流程运转起来。 subscribe123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, &quot;Plugin returned null Observer&quot;); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can&apos;t call onError because no way to know if a Disposable has been set or not // can&apos;t call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException(&quot;Actually not, but can&apos;t throw other exceptions due to RS&quot;); npe.initCause(e); throw npe; &#125;&#125; subscribe() 方法接收一个 Observer 对象作为参数，Observer 接口包含4个方法，用来响应不同的事件 123456public interface Observer&lt;T&gt; &#123; void onSubscribe(@NonNull Disposable d); void onNext(@NonNull T t); void onError(@NonNull Throwable e); void onComplete();&#125; 当一个 Observer 订阅了 Observable 之后，首先被调用的是 onSubscribe() 方法，附带一个 Disposable 对象，可以结束事件序列。然后 onNext() 被调用若干次表示有数据项发送过来，最后以 onError() 或 onComplete() 方法结束。 回到 subscribe() 方法，这段代码的重点只有一行，就是调用了 subscribeActual(observer) 方法。subscribeActual() 方法在 Observable 是抽象方法，有具体的子类实现，subscribeActual() 方法的实现体现了操作符作用。在这里调用的自然就是我们最后得到的 ObservableObserveOn 对象的 subscribeActual() 方法了。 123456789101112131415public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; ///这里scheduler实际上是HandlerScheduler对象,返回HandlerWorker Scheduler.Worker w = scheduler.createWorker(); ///订阅上游数据源，这里具体是ObservableSubscribeOn source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125; &#125;&#125; 这里程序进入的是第二个分支。首先创建了一个 Worker 对象，将来负责线程的切换。然后创建了一个 ObserveOnObserver 对象，由它来订阅上游的数据源，这里具体是 ObservableSubscribeOn。 那么这样就会调用 ObservableSubscribeOn 的父类 Observable 的 subscribe() 方法，subscribe() 方法的逻辑我们已经见过，方法内会调用具体子类也就是 ObservableSubscribeOn 的 subscribeActual() 方法。 12345678910111213public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; @Override public void subscribeActual(final Observer&lt;? super T&gt; s) &#123; ///创建一个包装类包装了ObserveOnObserver final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); ///调用下游ObserveOnObserver的onSubscribe()方法,所以onSubscribe()方法执行在订阅处所在的线程 s.onSubscribe(parent); ///setDisposable()是为了将子线程的操作加入Disposable管理中。scheduler实际是IoScheduler parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); &#125; 这里创建一个包装类 SubscribeOnObserver 来包装刚刚传进来的 ObserveOnObserver。然后将其作为 Disposable 类型调用了下游也就是 SubscribeOnObserver 的onSubscribe() 方法，那我们回头去看一下 1234567891011121314151617public void onSubscribe(Disposable s) &#123; ///校验this.s为空,s不为空 if (DisposableHelper.validate(this.s, s)) &#123; ///保存Disposable this.s = s; ///SubscribeOnObserver 不是QueueDisposable类型 if (s instanceof QueueDisposable) &#123; ...... &#125; ///创建一个queue 用于保存上游 onNext() push的数据 128 queue = new SpscLinkedArrayQueue&lt;T&gt;(bufferSize); ///actual就是我们自己创建的Observer回调下游观察者onSubscribe方法。 actual.onSubscribe(this); &#125; &#125; 这里的关键是调用了 actual 实例的 onSubscribe() 方法，这里的 actual 实际上就是我们自己创建的 Observer 对象，Observer 收到的第一个回调 onSubscribe() 方法就是在这里调用的，其中 Disposable 参数就是 ObserveOnObserver 对象。其实 onSunscribe() 回调中的 Disposable 参数都是上游包装 Observable 内部的包装 Observer。 由于这里还没切换线程，所以我们创建的 Observer 的 onSubscribe() 回调是在订阅处所在线程执行的。 然后回到 ObservableSubscribeOn 的 subscribeActual() 方法，后续的代码先创建了 SubscribeTask 对象，然后调用 IoScheduler 对象的 scheduleDirect() 方法进行线程切换。 先来看看 SubscribeTask 是个什么东西 12345678910111213final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; ///用SubscribeOnObserver订阅了上游ObservableMap,将运行在相应的Scheduler线程中 source.subscribe(parent); &#125;&#125; 其实就是一个 Runnable，会执行订阅上游 Observable 的操作，将会在 IoScheduler 的线程中执行。 下面就是线程调度的关键了，看看 IoScheduler 的 scheduleDirect() 方法是怎样切换线程的。 1234567891011121314151617181920public abstract class Scheduler &#123; public Disposable scheduleDirect(@NonNull Runnable run) &#123; return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS); &#125; public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123; ///调用具体IoScheduler实例的createWorker方法,返回EventLoopWorker final Worker w = createWorker(); ///直接返回run final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); ///在原始runnable上添加dispose流程,执行完毕后调用Worker的dispose方法 DisposeTask task = new DisposeTask(decoratedRun, w); w.schedule(task, delay, unit); return task; &#125;&#125; 这里调用了另一个重载的 scheduleDirect() 方法，方法中首先调用 IoScheduler 实例的 createWorker() 创建了 EventLoopWorker 对象。然后调用它的 seheduler() 方法进行实际的线程调度 1234567891011static final class EventLoopWorker extends Scheduler.Worker &#123; public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) &#123; if (tasks.isDisposed()) &#123; // don&apos;t schedule, we are unsubscribed return EmptyDisposable.INSTANCE; &#125; ///调用NewThreadWorker的scheduleActual,threadWorker从CachedWorkerPool中获取 return threadWorker.scheduleActual(action, delayTime, unit, tasks); &#125;&#125; threadWorker 是一个 ThreadWorker 实例，这里调用的 scheduleActual() 方法是其父类 NewThreadWorker 的方法。 12345678910111213141516171819202122232425262728293031public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) &#123; Runnable decoratedRun = RxJavaPlugins.onSchedule(run); ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent); if (parent != null) &#123; if (!parent.add(sr)) &#123; return sr; &#125; &#125; Future&lt;?&gt; f; try &#123; if (delayTime &lt;= 0) &#123; ///executor是ScheduledExecutorService线程池对象 // 在构造函数中初始化,核心线程数1,所以订阅发生在新线程 f = executor.submit((Callable&lt;Object&gt;)sr); &#125; else &#123; f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit); &#125; ///f是Future对象,包含结果 sr.setFuture(f); &#125; catch (RejectedExecutionException ex) &#123; if (parent != null) &#123; parent.remove(sr); &#125; RxJavaPlugins.onError(ex); &#125; return sr;&#125; 这里的关键就是线程池的相关代码，这里调用了 executor 的 submit() 方法，executor 是一个 ScheduledExecutorService 线程池对象，核心线程数为1，线程的创建由 ThreadFactory 子类 RxThreadFactory 来完成 1234567891011public Thread newThread(Runnable r) &#123; StringBuilder nameBuilder = new StringBuilder(prefix).append(&apos;-&apos;).append(incrementAndGet()); String name = nameBuilder.toString(); ///nonBlocking默认为false Thread t = nonBlocking ? new RxCustomThread(r, name) : new Thread(r, name); ///prioryty为5 t.setPriority(priority); t.setDaemon(true); return t; &#125; 可见我们指定的 IO 线程是一个后台线程。线程优先级的计算如下 12int priority = Math.max(Thread.MIN_PRIORITY, Math.min(Thread.MAX_PRIORITY, Integer.getInteger(KEY_IO_PRIORITY, Thread.NORM_PRIORITY))); 具体来说就是5. 回到 NewThreadWorker 的 scheduleActual() 方法，里面调用了线程池的 submit() 方法，最终会在新创建的线程中执行之前的 SubscribeTask ，导致 SubscribeOnObserver 在新线程中订阅了上游的 ObservableMap。 所以上游的全部操作包括数据的发射，数据处理都在该线程中执行。 既然上游的 ObservableMap 被订阅了，那么自然会调用它的 scheduleActual() 方法 123456789public final class ObservableMap&lt;T, U&gt; extends AbstractObservableWithUpstream&lt;T, U&gt; &#123; @Override public void subscribeActual(Observer&lt;? super U&gt; t) &#123; ///用MapObserver订阅上游ObservableCreate。 source.subscribe(new MapObserver&lt;T, U&gt;(t, function)); &#125;&#125; 只是简单地订阅了上游 Observable，而这次的 Observable 终于是事件流的源头 ObservableCreate了，意味着即将要开始发送事件。它的 subscribeActual() 方法如下 1234567891011121314protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; ///创建一个能向下游observer发送事件并能自由取消的对象 CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); ///调用MapObserver的onSubscribe方法 observer.onSubscribe(parent); try &#123; ///调用了我们创建的ObservableOnSubscribe对象的 subscribe 方法 source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; 程序首先调用了下游 MapObserver 的 onSubscribe() 方法，那么 MapObserver.onSubscribe() -&gt; SubscribeOnObserver.onSubscribe() 都会被调用，内部逻辑主要是将 Disposable 对象保存起来，在此不赘述了。 然后我们看到一句关键的代码 source.subscribe(parent)，调用我们一开始创建的 ObservableOnSubscribe 对象的 subscribe() 方法，数据的发送就是在这里被执行的。那么就会使用 ObservableEmitter 对象的 onNext() 方法发送若干数据，以 onComplete() 结束，来完成数据的发送，并且是在 onSubscribe 操作符指定的线程。而 ObservableOnSubscribe 的 subscribe() 方法接收的 ObservableEmitter 参数实际上就是 ObservableCreate 对象里面的一个内部类 CreateEmitter。可以猜测到它一定是将数据转发到下游 MapObserver 的，那么我们看一下它的 onNext() 方法 12345678910111213static final class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt;implements ObservableEmitter&lt;T&gt;, Disposable &#123; @Override public void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;)); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125; &#125; 不出所料 ObservableEmitter 没有做什么处理，调用 onNext() 方法发送给下游 MapObserver 12345678910111213141516171819202122232425262728static final class MapObserver&lt;T, U&gt; extends BasicFuseableObserver&lt;T, U&gt; &#123; @Override public void onNext(T t) &#123; ///onError或者onComplete之后done为true if (done) &#123; return; &#125; ///默认sourceMode是NONE if (sourceMode != NONE) &#123; actual.onNext(null); return; &#125; ///下游Observer接受的类型 U v; ///这一步执行变换,将上游传过来的T类型，利用Function转换成下游需要的U类型 try &#123; v = ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper function returned a null value.&quot;); &#125; catch (Throwable ex) &#123; fail(ex); return; &#125; actual.onNext(v); &#125;&#125; MapObserver 的 onNext() 方法主要做两件事，数据转型和发送至下游。转型实际上是通过调用用户指定的 Function 对象的 apply() 方法完成的。然后调用下游的 onNext() 方法，也即是 SubscribeOnObserver 12345678static final class SubscribeOnObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements Observer&lt;T&gt;, Disposable &#123; ///直接调用下游观察者的对应方法 @Override public void onNext(T t) &#123; actual.onNext(t); &#125; &#125; 那么我们来看一下下游 ObserveOnObserver 的 onNext() 方法，这也是线程切换的关键点之一 1234567891011121314151617181920212223242526272829303132public void onNext(T t) &#123; ///执行过error / complete 会是true if (done) &#123; return; &#125; ///如果数据源类型不是异步的， 默认不是 if (sourceMode != QueueDisposable.ASYNC) &#123; ///上游push过来的数据放入队列中 queue.offer(t); &#125; ///开始进入对应Workder线程，在线程里将队列中的数据去除发送给下游Observer schedule(); &#125; void schedule() &#123; if (getAndIncrement() == 0) &#123; ///worker是HandlerWorker，会执行该类的run方法,在MainLooper的Handler中执行 worker.schedule(this); &#125; &#125; @Override public void run() &#123; //默认是false if (outputFused) &#123; drainFused(); &#125; else &#123; //取出queue里的数据 发送 drainNormal(); &#125; &#125; ObserveOnObserver 并没有将数据直接发送给下游，而是先放入一个队列中，该队列的初始大小是128.然后再进行线程切换，在新线程中将数据取出再发送给下游。 schedule() 方法中调用了 Worker 对象的 sehedule() 方法，由于我们指定的是主线程，那么 Worker 对象的实例就是 HandlerWorker，其 schedule() 方法如下 12345678910111213141516171819202122232425public Disposable schedule(Runnable run, long delay, TimeUnit unit) &#123; if (run == null) throw new NullPointerException(&quot;run == null&quot;); if (unit == null) throw new NullPointerException(&quot;unit == null&quot;); if (disposed) &#123; return Disposables.disposed(); &#125; run = RxJavaPlugins.onSchedule(run); ScheduledRunnable scheduled = new ScheduledRunnable(handler, run); Message message = Message.obtain(handler, scheduled); message.obj = this; // Used as token for batch disposal of this worker&apos;s runnables. handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay))); // Re-check disposed state for removing in case we were racing a call to dispose(). if (disposed) &#123; handler.removeCallbacks(scheduled); return Disposables.disposed(); &#125; return scheduled; &#125; 关键的地方是 handler.sendMessageDelayed()，这里的 handler 实例是用 MainLooper 来构造的，所以传进去的 Runnable 将会在主线程中执行，也就是 ObserveOnObserver 中的 run() 方法将在主线程中执行。 run() 方法中又调用了 drainNormal() 方法，想必就是从队列中去除数据然后发送给下游了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void drainNormal() &#123; int missed = 1; final SimpleQueue&lt;T&gt; q = queue; final Observer&lt;? super T&gt; a = actual; for (;;) &#123; ///检查是否结束,是否没有数据要发送 if (checkTerminated(done, q.isEmpty(), a)) &#123; return; &#125; for (;;) &#123; boolean d = done; T v; try &#123; ///从队列中取出数据 v = q.poll(); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); s.dispose(); q.clear(); a.onError(ex); worker.dispose(); return; &#125; boolean empty = v == null; if (checkTerminated(d, empty, a)) &#123; return; &#125; if (empty) &#123; break; &#125; ///发送给下游 a.onNext(v); &#125; missed = addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125; &#125; 跟我们预料的一样，这里的 a 就是下游 Observer，也就是事件流最终点，那么我们的 Observer 就成功收到数据了。 将上面的流程进行简化可以用下面这样一个图表示，其中黑色表示订阅时所在线程，蓝色表示IO线程，红色表示主线程。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide源码解析（二）：缓存机制]]></title>
    <url>%2F2017%2F05%2F08%2FGlide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[本文是 Glide 源码分析系列的第二篇，主要通过分析源码总结 Glide 的缓存机制。 从加载流程揭开缓存机制的面纱首先回忆一下上一篇关于 Glide 加载流程源码分析的内容，我们从 Glide.with().load().into() 这个最简单最基本的用法入手，一步步深入源码，梳理出了完整的图片加载流程。由于当时分析重点在于整体流程的把握上，所以对于缓存相关的部分都是简单带过而没有进行深入分析。首先是为了避免文章篇幅过长，其次因为缓存它不是独立的部分，它埋藏在整个加载流程的各个环节中，所以对缓存机制的理解应该建立在对整体流程清晰的把握上。 而在本文中，我们将从整个加载流程入手，找出缓存相关的部分，进而还原出 Glide 缓存机制的整体面貌。然后再对各个部分进行详细分析。 那么我们开始来看看加载流程中被我们错过的缓存操作。 读取内存缓存我们在 GenericRequestBuilder 中构建了一个 GenericRequest 实例并交给 RequestTracker 去处理，执行它的 begin() 方法。在 GenericRequest 的 确定了 ImageView 的大小之后在 onSizeReady() 回调中调用了 Engine 的load() 进行加载。这时我们第一次遇到了缓存操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Engine implements EngineJobListener, MemoryCache.ResourceRemovedListener, EngineResource.ResourceListener &#123; public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher, DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder, Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) &#123; ...... final String id = fetcher.getId(); EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(), loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(), transcoder, loadProvider.getSourceEncoder()); /// 从LruResourceCache中获取 EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable); if (cached != null) &#123; ///GenericRequest cb.onResourceReady(cached); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key); &#125; return null; &#125; /// 从activeResources中获取 EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable); if (active != null) &#123; ///GenericRequest cb.onResourceReady(active); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key); &#125; return null; &#125; ...... &#125; private EngineResource&lt;?&gt; loadFromActiveResources(Key key, boolean isMemoryCacheable) &#123; if (!isMemoryCacheable) &#123; return null; &#125; EngineResource&lt;?&gt; active = null; WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key); if (activeRef != null) &#123; active = activeRef.get(); if (active != null) &#123; active.acquire(); &#125; else &#123; activeResources.remove(key); &#125; &#125; return active; &#125; ///从LruResourceCache中获取,若有则移除并放入activesource private EngineResource&lt;?&gt; loadFromCache(Key key, boolean isMemoryCacheable) &#123; if (!isMemoryCacheable) &#123; return null; &#125; EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key); if (cached != null) &#123; cached.acquire(); activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue())); &#125; return cached; &#125; @SuppressWarnings(&quot;unchecked&quot;) private EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123; Resource&lt;?&gt; cached = cache.remove(key); final EngineResource result; if (cached == null) &#123; result = null; &#125; else if (cached instanceof EngineResource) &#123; // Save an object allocation if we&apos;ve cached an EngineResource (the typical case). result = (EngineResource) cached; &#125; else &#123; result = new EngineResource(cached, true /*isCacheable*/); &#125; return result; &#125;&#125; 程序首先调用 loadFromCache() 尝试从 MemoryCache 中获取，如果命中缓存则将缓存从 MemoryCache 中移除并放入 activeResources，然后返回。如果缓存失效则尝试从 activeResources 中获取，如果都失效再构建 EngineRunnable 从磁盘或者网络获取。 是否决定从 MemoryCache 和 activeResources 中获取的前提条件是 isMemoryCacheable 为 true。这个值从 GenericRequestBuilder 传过来，默认为true，也就是说 Glide 默认开启内存缓存。除非你主动调用了 skipMemoryCache() 使该加载请求跳过内存缓存。该方法就是通过将 isMemoryCacheable 置为 false 实现的。 这里出现了 MemoryCache 和 activeResources，它们一起构成的 Glide 中的内存缓存。它们的 Key，都是由 url、图片大小、decoder、encoder等变量组成。MemoryCache 用于保存最近使用过而当前不在使用的 EngineResource，这也是缓存命中是需要将缓存移除并添加到 activeResources 的原因。其内部使用 LinkedHashMap，当大小达到一个阈值时通过 LRU 算法来清除。在 Glide 中 MemoryCache 的默认实现是 LruResourceCache，在 GlideBuilder 中被初始化。activeResources 用于保存当前正在被使用的 EngineResource，是一个使用 Key 作为键， EngineResource 的弱引用为值的 HashMap。 读取磁盘缓存当 MemoryCache 和 activeResources 都失效时，程序才构建一个 EngineRunnable 并交给线程池执行。在 EngineRunnable 的 run() 方法中就调用了 decode() 尝试从磁盘或网络获取图片，这里，我们第二次遇到了缓存操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class EngineRunnable implements Runnable, Prioritized &#123; @Override public void run() &#123; if (isCancelled) &#123; return; &#125; Exception exception = null; Resource&lt;?&gt; resource = null; try &#123; ///得到了Resource&lt;GlideDrawable&gt;对象 resource = decode(); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, &quot;Exception decoding&quot;, e); &#125; exception = e; &#125; if (isCancelled) &#123; if (resource != null) &#123; resource.recycle(); &#125; return; &#125; if (resource == null) &#123; /// 第一次走decode()尝试从磁盘获取,失败后会走这里 onLoadFailed(exception); &#125; else &#123; onLoadComplete(resource); &#125; &#125; private boolean isDecodingFromCache() &#123; return stage == Stage.CACHE; &#125; private Resource&lt;?&gt; decode() throws Exception &#123; if (isDecodingFromCache()) &#123; ///从磁盘缓存中decode图片,第一次会走这 return decodeFromCache(); &#125; else &#123; ///从源中decode图片,第二次会走这 return decodeFromSource(); &#125; &#125; private Resource&lt;?&gt; decodeFromCache() throws Exception &#123; Resource&lt;?&gt; result = null; try &#123; result = decodeJob.decodeResultFromCache(); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, &quot;Exception decoding result from cache: &quot; + e); &#125; &#125; if (result == null) &#123; result = decodeJob.decodeSourceFromCache(); &#125; return result; &#125;&#125; 在 decode() 方法中，决定从源获取图片之前，先调用 decodeFromCache() 方法尝试从磁盘中获取图片。而 decodeFromCache() 方法中又先后调用 decodeResultFromCache() 获取处理图 和 decodeSourceFromCache() 获取原图。 那么我们去看看这两个方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class DecodeJob&lt;A, T, Z&gt; &#123; ///从磁盘decode转化过的resource,然后transcode public Resource&lt;Z&gt; decodeResultFromCache() throws Exception &#123; if (!diskCacheStrategy.cacheResult()) &#123; return null; &#125; long startTime = LogTime.getLogTime(); ///Resource&lt;GifBitmapWrapper&gt; Resource&lt;T&gt; transformed = loadFromCache(resultKey); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Decoded transformed from cache&quot;, startTime); &#125; startTime = LogTime.getLogTime(); ///Resource&lt;GlideDrawable&gt; Resource&lt;Z&gt; result = transcode(transformed); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Transcoded transformed from cache&quot;, startTime); &#125; return result; &#125; public Resource&lt;Z&gt; decodeSourceFromCache() throws Exception &#123; if (!diskCacheStrategy.cacheSource()) &#123; return null; &#125; long startTime = LogTime.getLogTime(); ///Resource&lt;GifBitmapWrapper&gt; 使用的是OriginalKey Resource&lt;T&gt; decoded = loadFromCache(resultKey.getOriginalKey()); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Decoded source from cache&quot;, startTime); &#125; return transformEncodeAndTranscode(decoded); &#125; private Resource&lt;T&gt; loadFromCache(Key key) throws IOException &#123; File cacheFile = diskCacheProvider.getDiskCache().get(key); if (cacheFile == null) &#123; return null; &#125; Resource&lt;T&gt; result = null; try &#123; ///FileToStreamDecoder,将file解码成Resource&lt;GifBitmapWrapper&gt;实例是GifBitmapWrapperResource result = loadProvider.getCacheDecoder().decode(cacheFile, width, height); &#125; finally &#123; if (result == null) &#123; diskCacheProvider.getDiskCache().delete(key); &#125; &#125; return result; &#125;&#125; decodeResultFromCache() 方法和 decodeSourceFromCache() 方法内部都调用了 loadFromCache() 方法来获取磁盘缓存，只不过前者使用的参数是 resultKey 而后者使用的是 OriginalKey。这里的 loadProvider 是一个 LazyDiskCacheProvider 对象，里面封装了一个 InternalCacheDiskCacheFactory，当调用 getCacheDecoder() 时，方法内部将调用 InternalCacheDiskCacheFactory 的 build() 方法，最终返回一个 DiskLruCacheWrapper 对象。现在只要知道它是我们操作磁盘缓存的直接对象即可，内部原理将在文章后半部分进行分析。 它们得到的都是一个缓存文件，只不过前者写入的内容是变换后的图片，后者后者写入的内容是原始的图片。所以前者获取文件之后只需要进行解码和转码即可，而后者需要进行变换加上解码和转码。 decodeSourceFromCache() 方法中从磁盘缓存中获取原图之后调用了 transformEncodeAndTranscode() 方法进行变换和转码，这里也涉及到缓存的操作，这个会在后面讲到。 是否决定从磁盘缓存中获取取决于 DiskCacheStrategy，它是一个枚举类，用来表示一组缓存策略，cacheSource 属性表示是否缓存原图，cacheResult 属性表示是否缓存处理图。Glide 的默认的磁盘缓存是 RESULT，即只缓存处理图，也可以通过 diskCacheStrategy() 方法来指定。 123456789101112131415161718public enum DiskCacheStrategy &#123; /** Caches with both &#123;@link #SOURCE&#125; and &#123;@link #RESULT&#125;. */ ALL(true, true), /** Saves no data to cache. */ NONE(false, false), /** Saves just the original data to cache. */ SOURCE(true, false), /** Saves the media item after all transformations to cache. */ RESULT(false, true); private final boolean cacheSource; private final boolean cacheResult; DiskCacheStrategy(boolean cacheSource, boolean cacheResult) &#123; this.cacheSource = cacheSource; this.cacheResult = cacheResult; &#125;&#125; 往磁盘缓存写入原图当从磁盘缓存中既取不到原图也取不到处理图时，才会发起网络请求去获取。相应的逻辑在 DecodeJob 的 decodeFromSource() 方法中。 在 decodeFromSource() 方法中，程序首先调用了 decodeSource() 方法来从网络中获取 InputStream 以及解码成 Bitmap，然后调用 transformEncodeAndTranscode() 来进行图片的变换和转码。这两个步骤中都涉及到对缓存的操作。先来看看 decodeSource() 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private Resource&lt;T&gt; decodeSource() throws Exception &#123; Resource&lt;T&gt; decoded = null; try &#123; long startTime = LogTime.getLogTime(); ///ImageVideoFetcher,内部使用... 返回一个ImageVideoWrapper final A data = fetcher.loadData(priority); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Fetched data&quot;, startTime); &#125; if (isCancelled) &#123; return null; &#125; ///返回 Resource&lt;GifBitmapWrapper&gt; decoded = decodeFromSourceData(data); &#125; finally &#123; fetcher.cleanup(); &#125; return decoded; &#125; private Resource&lt;T&gt; decodeFromSourceData(A data) throws IOException &#123; final Resource&lt;T&gt; decoded; ///判断磁盘缓存策略中是否缓存source,缓存ImageVideoWrapper并decode(原始InputStream) if (diskCacheStrategy.cacheSource()) &#123; decoded = cacheAndDecodeSourceData(data); &#125; else &#123; ...... &#125; return decoded; &#125; private Resource&lt;T&gt; cacheAndDecodeSourceData(A data) throws IOException &#123; long startTime = LogTime.getLogTime(); ///loadProvider是FixedLoadProvider,里面封装了ImageVideoGifDrawableLoadProvider // 这里实际返回的ImageVideoWrapperEncoder SourceWriter&lt;A&gt; writer = new SourceWriter&lt;A&gt;(loadProvider.getSourceEncoder(), data); ///diskCacheProvider是一个LazyDiskCacheProvider,返回DiskLruCacheWrapper实例 ///resultKey由Engine构造decodejob的时候传进来,由EngineKeyFactory.builidKey返回. diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Wrote source to cache&quot;, startTime); &#125; startTime = LogTime.getLogTime(); Resource&lt;T&gt; result = loadFromCache(resultKey.getOriginalKey()); if (Log.isLoggable(TAG, Log.VERBOSE) &amp;&amp; result != null) &#123; logWithTimeAndKey(&quot;Decoded source from cache&quot;, startTime); &#125; return result; &#125; decodeSource() 方法中 DateFetcher 的 loadData() 方法从网络中获取数据之后，调用了 decodeFromSourceData() 方法开始进行解码。在 decodeFromSourceData() 方法中，解码前首先判断当前磁盘缓存策略，如果 cacheSource 为 true，那么解码前还有写入磁盘缓存的操作，也就是 cacheAndDecodeSourceData() 方法。方法中获取了 DiskLruCacheWrapper 对象然后调用了它的 put() 方法来写入缓存，最终会将从服务器获取的 InputSteream 写入一个缓存文件中，缓存对应的 Key 是由 Url 生成的 OriginalKey。 往磁盘缓存写入处理图回到 decodeSource() 方法，将图片解码之后，接着就是调用 transformEncodeAndTranscode() 进行变换和转码，这里也涉及到缓存的操作 123456789101112131415161718192021222324252627282930313233private Resource&lt;Z&gt; transformEncodeAndTranscode(Resource&lt;T&gt; decoded) &#123; long startTime = LogTime.getLogTime(); ///因为decodeSourceFromCache去取出的resource还没有经过transform,要先transform再缓存起来 Resource&lt;T&gt; transformed = transform(decoded); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Transformed resource from source&quot;, startTime); &#125; ///将transform后的resource写入缓存 bitmap或GifDrawable writeTransformedToCache(transformed); startTime = LogTime.getLogTime(); ///与decodeResultFromCache的第二步一样 Resource&lt;Z&gt; result = transcode(transformed); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Transcoded transformed from source&quot;, startTime); &#125; return result; &#125; private void writeTransformedToCache(Resource&lt;T&gt; transformed) &#123; if (transformed == null || !diskCacheStrategy.cacheResult()) &#123; return; &#125; long startTime = LogTime.getLogTime(); ///GifBitmapWrapperResourceEncoder SourceWriter&lt;Resource&lt;T&gt;&gt; writer = new SourceWriter&lt;Resource&lt;T&gt;&gt;(loadProvider.getEncoder(), transformed); ///resultKey是一个EngineKey diskCacheProvider.getDiskCache().put(resultKey, writer); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Wrote transformed from source to cache&quot;, startTime); &#125; &#125; transformEncodeAndTranscode() 方法中调用了 transform() 方法进行图片变换之后调用了 writeTransformedToCache() 方法来尝试将 Resource 写入磁盘缓存。具体是借助 GifBitmapWrapperResourceEncoder 来完成，有兴趣可以自行研究。 写入内存缓存按着图片的加载流程，经过变换和转码之后，会回到 EngineRunnable 的 run() 方法，然后回调 EngineJob 的 onResourceReady() 方法，通知图片获取已经完成。我们直接来到 handleResultOnMainThread() 方法，这时 EngineJob 正准备将 onResourceReady() 回调分发给 GenericRequest。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void handleResultOnMainThread() &#123; if (isCancelled) &#123; resource.recycle(); return; &#125; else if (cbs.isEmpty()) &#123; throw new IllegalStateException(&quot;Received a resource without any callbacks to notify&quot;); &#125; ///封装成一个EngineResource engineResource = engineResourceFactory.build(resource, isCacheable); hasResource = true; // Hold on to resource for duration of request so we don&apos;t recycle it in the middle of notifying if it // synchronously released by one of the callbacks. engineResource.acquire(); ///key是一个EngineKey。如果resource.isCacheable()为true,resource将添加到activeResources中,并在移除时加入memorycache listener.onEngineJobComplete(key, engineResource); ///这里的ResourceCallback就是GenericRequest,由GenericRequest调用EngineJob的load方法时传入 for (ResourceCallback cb : cbs) &#123; if (!isInIgnoredCallbacks(cb)) &#123; engineResource.acquire(); ///回调GenericRequest cb.onResourceReady(engineResource); &#125; &#125; // Our request is complete, so we can release the resource. engineResource.release();&#125;public void onEngineJobComplete(Key key, EngineResource&lt;?&gt; resource) &#123; Util.assertMainThread(); // A null resource indicates that the load failed, usually due to an exception. if (resource != null) &#123; ///监听engineresource的释放,从activeResources中移除,移除时放入MemoryCache中 resource.setResourceListener(key, this); if (resource.isCacheable()) &#123; ///将resource放到activeResources中 activeResources.put(key, new ResourceWeakReference(key, resource, getReferenceQueue())); &#125; &#125; // TODO: should this check that the engine job is still current? jobs.remove(key);&#125;@Overridepublic void onResourceReleased(Key cacheKey, EngineResource resource) &#123; Util.assertMainThread(); activeResources.remove(cacheKey); if (resource.isCacheable()) &#123; ///将resource转移到cache中 cache.put(cacheKey, resource); &#125; else &#123; resourceRecycler.recycle(resource); &#125;&#125; 注意 listener.onEngineJobComplete(key, engineResource) ，这里的 listener 正是 EngineJob 自身。在 EngineJob 的 onEngineJobComplete() 方法中给 EngineResource 设置了一个 ResourceListener，并且如果没有设置跳过内存缓存，将 EngineResource 放入 activeResources 中。那么 ResourceListener 做了什么呢？ ResourceListener 接口中只有 onResourceReleased() 一个方法，当 EngineResource 需要被释放时会回调该方法来通知监听者。这里的监听者正是 EngineJob，在 EngineJob 的 onResourceReleased() 方法中，将 EngineResource 从 activeResources 中删除，并且如果没有设置跳过内存缓存，则放入 MemoryCache 中，否则回收 EngineResource。这讲导致 EngineResource 中持有的 Bitmap 回收到 BitmapPool 中，等待复用。 接着图片将显示到 Target 上，加载流程结束，其中涉及的缓存操作也分析完毕。 那么，我们以缓存作为重点将加载流程梳理一下，就得到这样一个流程图 现在应该对整个缓存的流程有一个整体的认识了，下面将逐一各部分的内部细节，将涉及内存缓存、磁盘缓存和 BitmapPool。 内存缓存Glide 的内存缓存并不像传统的那样仅仅使用 强引用+LRU 算法，还加入了 ActiveResource 这个概念。防止 LruResourceCache 回收了正在使用的资源。 LruResourceCache + BitmapPool 缓存的最大空间默认为应用可用最大内存*0.4，低配手机是应用可用最大内存*0.33. 引用计数内存缓存包括 LruResourceCache 和 ActiveResources 存储的对象都是 EngineResource 对象。它是 Resource 对象的封装，并且内部维护对 Resource 的引用计数。调用 acquire() 引用计数+1，调用 release() 引用计数-1.当调用 release() 后引用计数为0时，由 ResourceListener（目前只有 Engine）来将其从 ActiveResources 移除并决定放入 LruResourceCache 还是调用 Resouece 的 recycler() 方法来回收相关资源，例如将 Bitmap 放入 BitmapPool。 LruResourceCacheLruResourceCache 用于保存最近被使用但是当前不在使用的资源。它的最大容量与屏幕分辨率和 Bitmap 质量参数有关，默认是 宽度 Pixels*高度 Piexls*ARGB_8888图片的质量参数*2,这样至少足够缓存两个屏幕大小的图片了。当容量过大时，使用 LRU 算法来移除最近最少使用的缓存项。 LruResourceCache 实现了 MemoryCache 接口，提供了 get()、remove()、getCurrentSize()、setResourceRemovedListener() 等方法，要注意的是并没有提供 get() 方法，在 Glide 中读取 LruResourceCache 往往是为了放入 ActiveResources，所以用 remove() 就足够了。同时继承了 LruCache，缓存逻辑的实现主要来自于 LruCache。LruCache 内部使用 LinkedHashMap 来实现 LRU 算法。没有十分复杂的逻辑，就不详细分析了。 还有值得注意的是，Engine 通过 setResourceRemovedListener() 方法设置了 ResourceRemovedListener。当一个缓存项因为 LruResourceCache 容量过大使用 LRU 算法被移除(不包括调用 remove() 方法移除的情况)时，将接受到 onResourceRemoved() 回调。Engine 在 onResourceRemoved() 调用了 Resource 的 recycler() 方法，这意味着 Resource 持有的 Bitmap 将会放入到 BitmapPool 中。 总结一下，LruResourceCache 用于保存最近被使用但是当前不在使用的资源。其中缓存的来源只有一个：ActiveResources。当 ActiveResources 中的缓存不再被使用时，会被移除，放入 LruResourceCache 中。缓存的去向有两个：一个是缓存通过 remove() 被读取时，转移到 ActiveResources 中，第二个是最近使用较少被 LRU 算法移除，然后相关的 Bitmap 资源回收到 BitmapPool。 ActiveResourcesActiveResources 用于保存当前正在使用的资源，它其实就是一个裸露的 HashMap，对缓存的读取与写入就是 get() 和 put() 方法的调用。它使用 EngineKey 为键，使用 EngineResource 的弱引用为值。所以也没有容量大小可言。 虽说 ActiveResources 中的资源是当前正在使用的资源，Glide 也提供了负责清理 ActiveResources 弱可达资源的实现(可能是某些特殊场景下没有调用 release() 会导致 ActiveResources 中的资源实际上不在使用了？)。实现方法是构造 EngineResource 的弱引用 WeakReference 时传进 ReferenceQueue 来监听弱引用的回收。当系统检测到该 EngineResource 是弱可达，即不在被使用时，就将该弱引用放入 ReferenceQueue 中。如果 ReferenceQueue 不为空，就说明 EngineResource 该被回收了，可是在什么时候回收呢？ Glide 在当前线程对应 Looper 所对应的 MessageQueue 中通过 addIdleHandler() 方法添加了一个 IdleHandler 实例 RefQueueIdleHandler，当 MessageQueue 空闲的时候就会回调 IdleHandler 的 queueIdle() 方法，在 queueIdle() 方法中清理 WeakReference 被回收的 activeResources 资源。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private EngineResource&lt;?&gt; loadFromCache(Key key, boolean isMemoryCacheable) &#123; if (!isMemoryCacheable) &#123; return null; &#125; EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key); if (cached != null) &#123; cached.acquire(); activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue())); &#125; return cached;&#125;private static class ResourceWeakReference extends WeakReference&lt;EngineResource&lt;?&gt;&gt; &#123; private final Key key; public ResourceWeakReference(Key key, EngineResource&lt;?&gt; r, ReferenceQueue&lt;? super EngineResource&lt;?&gt;&gt; q) &#123; super(r, q); this.key = key; &#125;&#125;private ReferenceQueue&lt;EngineResource&lt;?&gt;&gt; getReferenceQueue() &#123; if (resourceReferenceQueue == null) &#123; resourceReferenceQueue = new ReferenceQueue&lt;EngineResource&lt;?&gt;&gt;(); MessageQueue queue = Looper.myQueue(); queue.addIdleHandler(new RefQueueIdleHandler(activeResources, resourceReferenceQueue)); &#125; return resourceReferenceQueue;&#125;// Responsible for cleaning up the active resource map by remove weak references that have been cleared.private static class RefQueueIdleHandler implements MessageQueue.IdleHandler &#123; private final Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources; private final ReferenceQueue&lt;EngineResource&lt;?&gt;&gt; queue; public RefQueueIdleHandler(Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources, ReferenceQueue&lt;EngineResource&lt;?&gt;&gt; queue) &#123; this.activeResources = activeResources; this.queue = queue; &#125; @Override public boolean queueIdle() &#123; ResourceWeakReference ref = (ResourceWeakReference) queue.poll(); if (ref != null) &#123; activeResources.remove(ref.key); &#125; return true; &#125;&#125; 磁盘缓存除了内存缓存之外， Glide 还设计了磁盘缓存。磁盘缓存的默认路径在 /data/data/\/cache/image_manager_disk_cache,默认的大小为 250MB，默认的实现类是 DiskLruCacheWrapper。 Glide 的磁盘缓存默认只缓存处理图，不过可以根据需要通过设置 DiskCacheStrategy 来定制缓存策略。Glide 中不管是原图还是处理图，每张图片都与一个缓存文件对应，存取原图时使用 OriginalKey,内部封装了图片的 Url 和 Signature 信息。而存取处理图时使用 EngineKey 内部封装了图片的 Url 和 Signature 之外，还包括图片尺寸和图片处理流程中相关的 Decoder、Encoder、Transformation 所返回的 id，，通过这些信息就能唯一确定一张图片了。 DiskLruCacheWrapperDiskLruCacheWrapper 实现了 DiskCache 接口，提供的方法非常简洁，提供了 get()、put()、delete()、clear() 四个方法。DiskLruCacheWrapper 内部封装了 DiskLruCache 对象，缓存文件的管理由它来完成。 下面从 DiskLruCacheWrapper 的角度分析一下缓存的写入与读取。 缓存写入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public File get(Key key) &#123; ///使用SHA-256算法生成唯一String String safeKey = safeKeyGenerator.getSafeKey(key); File result = null; try &#123; //It is possible that the there will be a put in between these two gets. If so that shouldn&apos;t be a problem //because we will always put the same value at the same key so our input streams will still represent //the same data final DiskLruCache.Value value = getDiskCache().get(safeKey); if (value != null) &#123; result = value.getFile(0); &#125; &#125; catch (IOException e) &#123; if (Log.isLoggable(TAG, Log.WARN)) &#123; Log.w(TAG, &quot;Unable to get from disk cache&quot;, e); &#125; &#125; return result;&#125;public String getSafeKey(Key key) &#123; String safeKey; synchronized (loadIdToSafeHash) &#123; safeKey = loadIdToSafeHash.get(key); &#125; if (safeKey == null) &#123; try &#123; MessageDigest messageDigest = MessageDigest.getInstance(&quot;SHA-256&quot;); key.updateDiskCacheKey(messageDigest); safeKey = Util.sha256BytesToHex(messageDigest.digest()); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; synchronized (loadIdToSafeHash) &#123; loadIdToSafeHash.put(key, safeKey); &#125; &#125; return safeKey;&#125;private synchronized DiskLruCache getDiskCache() throws IOException &#123; if (diskLruCache == null) &#123; diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize); &#125; return diskLruCache;&#125; put() 方法首先调用 getSafeKey() 方法将 Key 转化为一个唯一的字符串，原理是将 Key 中封装的信息(原图就是图片的 Url，处理图就是 Url、尺寸、Decoder等)通过 SHA-256 算法进行编码。缓存的存取都是使用这个字符串，同时这也是缓存文件的文件名。 getDiskCache() 方法返回了 DiskLruCache，方法内部调用了它的静态方法 open() 来创建或返回一个现有的 DiskLruCache 实例。 返回 DiskLruCache 实例之后，通过之前生成的字符串作为参数调用了它的 get() 方法，该方法 返回 DiskLruCache.Value 对象，然后通过 Value 对象来返回一个缓存文件。DiskLruCacheWrapper 就完成了，之后就由 ResourceDecoder 获取文件的 InputSteream 然后解码成 Bitmap 了。 put() 的逻辑非常简单，因为 DiskLruCache 已经封装了缓存实现的细节。DiskLruCache 的实现细节后面再详细分析。 缓存读取12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public void put(Key key, Writer writer) &#123; String safeKey = safeKeyGenerator.getSafeKey(key); writeLocker.acquire(key); try &#123; DiskLruCache.Editor editor = getDiskCache().edit(safeKey); // Editor will be null if there are two concurrent puts. In the worst case we will just silently fail. if (editor != null) &#123; try &#123; File file = editor.getFile(0); if (writer.write(file)) &#123; editor.commit(); &#125; &#125; finally &#123; editor.abortUnlessCommitted(); &#125; &#125; &#125; catch (IOException e) &#123; if (Log.isLoggable(TAG, Log.WARN)) &#123; Log.w(TAG, &quot;Unable to put to disk cache&quot;, e); &#125; &#125; finally &#123; writeLocker.release(key); &#125;&#125;class SourceWriter&lt;DataType&gt; implements DiskCache.Writer &#123; private final Encoder&lt;DataType&gt; encoder; private final DataType data; public SourceWriter(Encoder&lt;DataType&gt; encoder, DataType data) &#123; this.encoder = encoder; this.data = data; &#125; @Override public boolean write(File file) &#123; boolean success = false; OutputStream os = null; try &#123; os = fileOpener.open(file); success = encoder.encode(data, os); &#125; catch (FileNotFoundException e) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, &quot;Failed to find file to write to disk cache&quot;, e); &#125; &#125; finally &#123; if (os != null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; // Do nothing. &#125; &#125; &#125; return success; &#125;&#125; put() 方法接收两个参数，Key 和 Writer，实际上接收的是 SourceWriter 实例，其内部封装了一个 Encoder。put() 方法内部也是先生成字符串 safeKey，然后通过 DiskLruCache 实例的 edit() 方法来获取一个 Editor 实例，进而获取一个缓存文件。然后调用 Writer 的 write() 方法，write() 方法内部将数据写入缓存文件的 OutputStream 中。数据写入完成后调用 Editor 的 commit() 方法来刷新数据。 看来 put() 和 get() 方法的逻辑都比较简单，都是通过 Key 生成字符串，然后通过字符串获取对应的缓存文件，然后使 ResourceDecoder 或者 Encoder 来读取或者写入数据。那么我们来看看 DiskLruCache 是怎么管理缓存文件的。 DiskLruCacheDiskLruCache 表示磁盘缓存，它管理了多个缓存文件，每个 Key 对应一个或多个缓存文件，运行时相关信息保存在一个 LinkedHashMap 中，LinkedHashMap 以 String 为键，以一个 Entry 对象为值。当容量过大时使用 LinkedHashMap 的 LRU 算法来移除 Entry。 Entry 用来表示一个缓存实体，封装了一些相关信息。我们看看它的构造函数 1234567891011121314151617181920private Entry(String key) &#123; this.key = key; ///valueCount默认是1 this.lengths = new long[valueCount]; cleanFiles = new File[valueCount]; dirtyFiles = new File[valueCount]; // The names are repetitive so re-use the same builder to avoid allocations. StringBuilder fileBuilder = new StringBuilder(key).append(&apos;.&apos;); int truncateTo = fileBuilder.length(); for (int i = 0; i &lt; valueCount; i++) &#123; fileBuilder.append(i); ///cleanFiles用key.1命名 cleanFiles[i] = new File(directory, fileBuilder.toString()); fileBuilder.append(&quot;.tmp&quot;); ///dirtyFiles用key.1.tmp命名 dirtyFiles[i] = new File(directory, fileBuilder.toString()); fileBuilder.setLength(truncateTo); &#125;&#125; 可见 Entry 封装了 Key，对应的缓存文件和文件大小等信息。一个缓存实体对应两个缓存文件，cleanFile 文件中的数据时刻是干净可读的，dirtyFile 的作用是作为临时文件，当需要写入缓存时，返回的是 dirtyFile，等调用 commit() 方法时再更新数据。这样缓存的写入时也不会影响缓存的读取了。dirtyFile 用 key.1命名，dirtyFiles 用 key.1.tmp 命名，知道缓存 Key 就知道对应的缓存文件了。 缓存构建磁盘缓存与内存缓存不同，内存缓存在程序每次重新启动时都是空白的全新的状态，需要一个预热的过程，等缓存写入一定量的时候才能开始发挥作用，而磁盘缓存则不能受程序重新启动的影响，程序重新启动时，要能够自动恢复到上次运行的状态，每个 Key 对应哪个缓存文件、每个缓存的大小、哪些缓存文件的数据是干净的、哪些缓存文件的数据是不正常的写入需要删除、当前磁盘缓存的大小等等，都需要实时管理好。这就需要有一个文件实时记录下磁盘缓存的相关信息，以便能够随时恢复。DiskLruCache 就用到了这样一个文件，文件名为 journal。我们先来看看该文件的格式。 12345678910111213libcore.io.DiskLruCache11001CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832DIRTY 335c4c6028171cfddfbaae1a9c313c52CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934REMOVE 335c4c6028171cfddfbaae1a9c313c52DIRTY 1ab96a171faeeee38496d8b330771a7aCLEAN 1ab96a171faeeee38496d8b330771a7a 1600READ 335c4c6028171cfddfbaae1a9c313c52READ 3400330d1dfc7f3f7f4b8d4d803dfcf6 这是典型的 journal 文件内容。文件的前5行是文件头 第一行 固定为 libcore.io.DiskLruCache 第二行 版本号，源码中定为1 第三行 应用版本号，由 DiskLruCache 的使用者指定 第四行 valueCount，每个 Key 对应几个文件，源码中定为1 第五行 空行 第6行开始记录的是磁盘缓存的操作记录，每一行的格式为操作类型+Key+可选数据项。数据项之间用空格分隔，如果操作类型是 CLEAN，那么可选数据项是数字，描述缓存文件的大小。下面介绍一下四种操作类型 DIRTY 表示一个 Entry 被创建或正在写入，一个合法的 DIRTY 操作后面必须接着 CLEAN 操作或者 REMOVE 操作，否则表示该文件只是临时文件，应该被删除。 CLEAN 表示一个 Entry 被成功写入，可以被读取。CLEAN 行后面应该接着 valueCount 个数字表示每个缓存文件的大小 READ 表示一个 Entry 被读取 REMOVE 表示一个 Entry 被删除 journal 文件记录了每一个对磁盘缓存的操作，通过读取这个文件，程序就能还原出磁盘缓存的状态了。下面来看看磁盘缓存具体的构建过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize) throws IOException &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); &#125; if (valueCount &lt;= 0) &#123; throw new IllegalArgumentException(&quot;valueCount &lt;= 0&quot;); &#125; // If a bkp file exists, use it instead. ///判断是否有journal备份文件,如果有则进一步判断有无journal源文件,有则删除备份文件,无则将备份文件改名为源文件 File backupFile = new File(directory, JOURNAL_FILE_BACKUP); if (backupFile.exists()) &#123; File journalFile = new File(directory, JOURNAL_FILE); // If journal file also exists just delete backup file. if (journalFile.exists()) &#123; backupFile.delete(); &#125; else &#123; renameTo(backupFile, journalFile, false); &#125; &#125; // Prefer to pick up where we left off. ///有journal源文件则从该文件中加载到新的DiskLruCache DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize); if (cache.journalFile.exists()) &#123; try &#123; cache.readJournal(); cache.processJournal(); return cache; &#125; catch (IOException journalIsCorrupt) &#123; System.out .println(&quot;DiskLruCache &quot; + directory + &quot; is corrupt: &quot; + journalIsCorrupt.getMessage() + &quot;, removing&quot;); cache.delete(); &#125; &#125; // Create a new empty cache. ///既没有备份文件也没有原journal文件,新建一个 directory.mkdirs(); cache = new DiskLruCache(directory, appVersion, valueCount, maxSize); cache.rebuildJournal(); return cache;&#125; DiskLruCache 在 open() 方法中构建。构建 DiskLruCache 需要指定目录、应用版本、每个 Key 的缓存文件个数、磁盘缓存的最大容量。 程序首先判断是否有 journal 备份文件(备份文件命名为 journal.bkp)，如果有的话则进一步判断有无 journal 原文件，有则删除备份文件，无则将备份文件改名为原文件。 接下来再次判断 journal 文件是否存在 journal 文件存在 如果 journal 文件存在则调用 readJournal() 和 processJournal() 方法。先来看 readJournal() 123456789101112131415161718192021222324252627282930313233343536373839404142private void readJournal() throws IOException &#123; StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Util.US_ASCII); try &#123; ///校验文件头 String magic = reader.readLine(); String version = reader.readLine(); String appVersionString = reader.readLine(); String valueCountString = reader.readLine(); String blank = reader.readLine(); if (!MAGIC.equals(magic) || !VERSION_1.equals(version) || !Integer.toString(appVersion).equals(appVersionString) || !Integer.toString(valueCount).equals(valueCountString) || !&quot;&quot;.equals(blank)) &#123; throw new IOException(&quot;unexpected journal header: [&quot; + magic + &quot;, &quot; + version + &quot;, &quot; + valueCountString + &quot;, &quot; + blank + &quot;]&quot;); &#125; int lineCount = 0; while (true) &#123; try &#123; ///处理一行 readJournalLine(reader.readLine()); lineCount++; &#125; catch (EOFException endOfJournal) &#123; break; &#125; &#125; redundantOpCount = lineCount - lruEntries.size(); // If we ended on a truncated line, rebuild the journal before appending to it. if (reader.hasUnterminatedLine()) &#123; rebuildJournal(); &#125; else &#123; journalWriter = new BufferedWriter(new OutputStreamWriter( new FileOutputStream(journalFile, true), Util.US_ASCII)); &#125; &#125; finally &#123; Util.closeQuietly(reader); &#125;&#125; 首先校验文件头，然后循环调用 readJournalLine() 方法处理每一行 1234567891011121314151617181920212223242526272829303132333435363738394041private void readJournalLine(String line) throws IOException &#123; int firstSpace = line.indexOf(&apos; &apos;); if (firstSpace == -1) &#123; throw new IOException(&quot;unexpected journal line: &quot; + line); &#125; ///从行中读取key 格式 REMOVE|CLEAN|DIRTY key 文件大小(知道了key也就知道了key对应的cleanFile和dirtyFile) int keyBegin = firstSpace + 1; int secondSpace = line.indexOf(&apos; &apos;, keyBegin); final String key; if (secondSpace == -1) &#123; key = line.substring(keyBegin); ///处理 remove if (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123; lruEntries.remove(key); return; &#125; &#125; else &#123; key = line.substring(keyBegin, secondSpace); &#125; Entry entry = lruEntries.get(key); if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; ///如果是clean,那么readable就为true if (secondSpace != -1 &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123; String[] parts = line.substring(secondSpace + 1).split(&quot; &quot;); entry.readable = true; entry.currentEditor = null; entry.setLengths(parts); &#125; else if (secondSpace == -1 &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123; entry.currentEditor = new Editor(entry); &#125; else if (secondSpace == -1 &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123; // This work was already done by calling lruEntries.get(). &#125; else &#123; throw new IOException(&quot;unexpected journal line: &quot; + line); &#125;&#125; 先取出行中的 Key，如果是 REMOVE 操作，则将 Entry 从 LinkedHashMap 中移除。一个 Entry 表示一个缓存实体，封装了 Key、对应的缓存文件、文件大小 等信息。 如果 Key 对应的 Entry 不存在，则创建一个，然后放入 LinkedHashMap 中。最后根据操作类型 CLEAN 还是 DIRTY，进行一些属性初始化。如果 Entry 的 currentEditor 属性不为空，表示当前正在写入。 readJournalLine() 主要就是读取 journal 文件按照操作记录来还原了 LinkedHashMap。但是仔细分析可以发现它还没处理好那些单独出现的 DIRTY 记录，这些 Entry 应在被删除。那么我们接下来看看 processJournal() 方法。 123456789101112131415161718private void processJournal() throws IOException &#123; deleteIfExists(journalFileTmp); for (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123; Entry entry = i.next(); if (entry.currentEditor == null) &#123; for (int t = 0; t &lt; valueCount; t++) &#123; size += entry.lengths[t]; &#125; &#125; else &#123; entry.currentEditor = null; for (int t = 0; t &lt; valueCount; t++) &#123; deleteIfExists(entry.getCleanFile(t)); deleteIfExists(entry.getDirtyFile(t)); &#125; i.remove(); &#125; &#125;&#125; processJournal() 果然对这部分 Entry 做了清理，判断依据是如果是单独出现的 DIRTY 记录，那么该 Entry 的 currentEditor 必定是不为空的。同时 processJournal() 也统计了当前磁盘磁盘缓存的大小。 那么 journal 文件存在的情况就分析完了。 journal 文件不存在 如果文件不存在，则创建目录，新建 DiskLryCache ，调用 rebuildJournal() 方法生成 journal 文件。 1234567891011121314151617181920212223242526272829303132333435363738private synchronized void rebuildJournal() throws IOException &#123; if (journalWriter != null) &#123; journalWriter.close(); &#125; Writer writer = new BufferedWriter( new OutputStreamWriter(new FileOutputStream(journalFileTmp), Util.US_ASCII)); try &#123; writer.write(MAGIC); writer.write(&quot;\n&quot;); writer.write(VERSION_1); writer.write(&quot;\n&quot;); writer.write(Integer.toString(appVersion)); writer.write(&quot;\n&quot;); writer.write(Integer.toString(valueCount)); writer.write(&quot;\n&quot;); writer.write(&quot;\n&quot;); for (Entry entry : lruEntries.values()) &#123; if (entry.currentEditor != null) &#123; writer.write(DIRTY + &apos; &apos; + entry.key + &apos;\n&apos;); &#125; else &#123; writer.write(CLEAN + &apos; &apos; + entry.key + entry.getLengths() + &apos;\n&apos;); &#125; &#125; &#125; finally &#123; writer.close(); &#125; if (journalFile.exists()) &#123; renameTo(journalFile, journalFileBackup, true); &#125; renameTo(journalFileTmp, journalFile, false); journalFileBackup.delete(); journalWriter = new BufferedWriter( new OutputStreamWriter(new FileOutputStream(journalFile, true), Util.US_ASCII));&#125; 首先创建 journal.tmp 文件，写入文件头，然后将临时文件重新命名为 journal 原文件。 那么 DiskLruCache 磁盘缓存的构建就分析完毕了，主要是当操作日志文件 journal 文件存在时，通过读取文件来还原 LinkHashMap，同时统计当前磁盘缓存的大小。 缓存写入需要写入缓存时，通常先调用 edit() 方法获取一个 Editor 对象，通过该对象的 getFile() 方法获取一个文件以供写入缓存，写入成功后 调用 Editor 对象的 commit() 方法来提交写入的数据。 1234567891011121314151617181920212223242526272829public Editor edit(String key) throws IOException &#123; return edit(key, ANY_SEQUENCE_NUMBER);&#125;private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123; checkNotClosed(); Entry entry = lruEntries.get(key); if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) &#123; return null; // Value is stale. &#125; if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; else if (entry.currentEditor != null) &#123; return null; // Another edit is in progress. &#125; Editor editor = new Editor(entry); entry.currentEditor = editor; // Flush the journal before creating files to prevent file leaks. journalWriter.append(DIRTY); journalWriter.append(&apos; &apos;); journalWriter.append(key); journalWriter.append(&apos;\n&apos;); journalWriter.flush(); return editor;&#125; edit() 方法首先通过 key 在 LinkedHashMap 中获取 Entry，如果 Entry 为空则创建一个放入 LinkedHashMap 中。然后创建一个 Editor 对象并设置到 Entry 的 currentEditor 属性中。最后在 journal 新增一条 DIRTY 记录，表示该 key 的缓存文件正在被写入。 接下来看看 Editor 的 getFile() 方法 123456789101112131415public File getFile(int index) throws IOException &#123; synchronized (DiskLruCache.this) &#123; if (entry.currentEditor != this) &#123; throw new IllegalStateException(); &#125; if (!entry.readable) &#123; written[index] = true; &#125; File dirtyFile = entry.getDirtyFile(index); if (!directory.exists()) &#123; directory.mkdirs(); &#125; return dirtyFile; &#125; &#125; getFile() 方法返回 Entry 对应的 dirtyFile。 向 Editor 返回的文件写入缓存数据后，需要调用 commit() 方法提交数据，否则 dirtyFile 中的数据将被视为非法写入而被删除。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 public void commit() throws IOException &#123; // The object using this Editor must catch and handle any errors // during the write. If there is an error and they call commit // anyway, we will assume whatever they managed to write was valid. // Normally they should call abort. completeEdit(this, true); committed = true; &#125; private synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123; Entry entry = editor.entry; if (entry.currentEditor != editor) &#123; throw new IllegalStateException(); &#125; // If this edit is creating the entry for the first time, every index must have a value. ///如果这个记录以前有值,则readable为TRUE if (success &amp;&amp; !entry.readable) &#123; for (int i = 0; i &lt; valueCount; i++) &#123; if (!editor.written[i]) &#123; editor.abort(); throw new IllegalStateException(&quot;Newly created entry didn&apos;t create value for index &quot; + i); &#125; if (!entry.getDirtyFile(i).exists()) &#123; editor.abort(); return; &#125; &#125; &#125; //将dirty重命名为clean for (int i = 0; i &lt; valueCount; i++) &#123; File dirty = entry.getDirtyFile(i); if (success) &#123; if (dirty.exists()) &#123; File clean = entry.getCleanFile(i); dirty.renameTo(clean); long oldLength = entry.lengths[i]; long newLength = clean.length(); entry.lengths[i] = newLength; size = size - oldLength + newLength; &#125; &#125; else &#123; deleteIfExists(dirty); &#125; &#125; redundantOpCount++; entry.currentEditor = null; ///在journal文件中添加一条记录 if (entry.readable | success) &#123; entry.readable = true; journalWriter.append(CLEAN); journalWriter.append(&apos; &apos;); journalWriter.append(entry.key); journalWriter.append(entry.getLengths()); journalWriter.append(&apos;\n&apos;); if (success) &#123; entry.sequenceNumber = nextSequenceNumber++; &#125; &#125; else &#123; lruEntries.remove(entry.key); journalWriter.append(REMOVE); journalWriter.append(&apos; &apos;); journalWriter.append(entry.key); journalWriter.append(&apos;\n&apos;); &#125; journalWriter.flush(); if (size &gt; maxSize || journalRebuildRequired()) &#123; executorService.submit(cleanupCallable); &#125;&#125; commit() 方法内部又调用了 completeEdit() 方法。completeEdit() 方法主要将 dirtyFile 重命名为 cleanFile，重新计算缓存大小，然后在 journal 文件中增加一条 CLEAN 记录。 redundantOpCount 变量用来记录磁盘缓存的操作次数，当操作次数大于某个值时，就会根据 LinkedHashMap 重新创建 journal 文件，以防止 journal 文件过大。 缓存读取读取缓存时调用 get() 方法即可，它返回一个 Value 对象，表示 Entry 的一个快照。 1234567891011121314151617181920212223242526272829public synchronized Value get(String key) throws IOException &#123; checkNotClosed(); Entry entry = lruEntries.get(key); if (entry == null) &#123; return null; &#125; if (!entry.readable) &#123; return null; &#125; for (File file : entry.cleanFiles) &#123; // A file must have been deleted manually! if (!file.exists()) &#123; return null; &#125; &#125; redundantOpCount++; journalWriter.append(READ); journalWriter.append(&apos; &apos;); journalWriter.append(key); journalWriter.append(&apos;\n&apos;); if (journalRebuildRequired()) &#123; executorService.submit(cleanupCallable); &#125; return new Value(key, entry.sequenceNumber, entry.cleanFiles, entry.lengths);&#125; 主要是用过 key 获取 Entry 的 cleanFile，封装为 Value 对象返回，同时在 journal 文件中新增一条 READ 记录。 BitmapPool虽然有了图片内存缓存程序在一般情况都都能工作得很好，不会出现大的问题，但是内存缓存的容量总是有限度的，不能无限制地增长，所以程序还是会周期性的申请和释放内存。特别是在一个长列表快速滑动时，会造成大量的图片申请和释放，导致 GC 频繁，进而产生卡顿。 应用运行时图片内存往往占相当大的一部分，如果这部分内存能够尽量的复用，就能够显著地减少内存的频繁申请和释放了。基于这个考虑，Glide 针对 Bitmap 设计了复用方案，这就是 BitmapPool。 Glide 构建了一个 BitmapPool，图片的 Bitmap 的申请和释放都需要通过它来处理。需要加载新的图片时，先从 BitmapPool 中查找有没有相应大小或者稍大一点的 Bitmap，有则直接使用，没有再创建新的 Bimap。一个长列表中的图片往往是大小相同的，所以这个复用率还是相当可观的。 BitmapPool 的最大容量与屏幕分辨率有关，默认是 宽度 Pixels*高度 Piexls*ARGB_8888图片的质量参数*4,这样至少足够缓存四个屏幕大小的图片。容量到达阈值时，使用 LRU 算法从最近最少使用的图片尺寸中移除图片。 复用策略BitmapPool 使用策略模式来封装不同的复用策略，策略接口是 LruPoolStrategy，定义了 put()、get()、getSize() 等方法。Glide 中有两种复用策略 AttributeStrategy 复用的图片需要图片的尺寸和 Bitmap.Config 完全一致 SizeConfigStrategy 复用要求相对宽松，复用的图片需要 Bitmap.Config 一致，但复用图片的所需内存比原图小即可。确保 Bitmap.Config 一致后，如果有内存大小一致的图片则直接复用，没有则选取内存稍大一点的图片。需要 KITKAT 以上版本 Glide 在 KITKAT 以上系统中采用 SizeConfigStrategy，否则采用 AttributeStrategy。显然采取 SizeConfigStrategy 的复用率更高。之所以有这两者的区分，跟 Bitmap 的 reconfigure() 方法有关，BitmapPool 能够复用旧图片的内存得益于这个方法，这个方法是在 KITKAT(API 19) 增加的。该方法的注释如下 123456789101112131415161718192021222324252627282930313233343536373839404142/** * &lt;p&gt;Modifies the bitmap to have a specified width, height, and &#123;@link * Config&#125;, without affecting the underlying allocation backing the bitmap. * Bitmap pixel data is not re-initialized for the new configuration.&lt;/p&gt; * * &lt;p&gt;This method can be used to avoid allocating a new bitmap, instead * reusing an existing bitmap&apos;s allocation for a new configuration of equal * or lesser size. If the Bitmap&apos;s allocation isn&apos;t large enough to support * the new configuration, an IllegalArgumentException will be thrown and the * bitmap will not be modified.&lt;/p&gt; * * &lt;p&gt;The result of &#123;@link #getByteCount()&#125; will reflect the new configuration, * while &#123;@link #getAllocationByteCount()&#125; will reflect that of the initial * configuration.&lt;/p&gt; * * &lt;p&gt;WARNING: This method should NOT be called on a bitmap currently used * by the view system. It does not make guarantees about how the underlying * pixel buffer is remapped to the new config, just that the allocation is * reused. Additionally, the view system does not account for bitmap * properties being modifying during use, e.g. while attached to * drawables.&lt;/p&gt; * * @see #setWidth(int) * @see #setHeight(int) * @see #setConfig(Config) */public void reconfigure(int width, int height, Config config) &#123; checkRecycled(&quot;Can&apos;t call reconfigure() on a recycled bitmap&quot;); if (width &lt;= 0 || height &lt;= 0) &#123; throw new IllegalArgumentException(&quot;width and height must be &gt; 0&quot;); &#125; if (!isMutable()) &#123; throw new IllegalStateException(&quot;only mutable bitmaps may be reconfigured&quot;); &#125; if (mBuffer == null) &#123; throw new IllegalStateException(&quot;native-backed bitmaps may not be reconfigured&quot;); &#125; nativeReconfigure(mNativeBitmap, width, height, config.nativeInt, mBuffer.length); mWidth = width; mHeight = height;&#125; 简单来说，reconfigure() 方法能够在不重新初始化 Bitmap 和不影响底层内存分配的前提下修改 Bitmap 的尺寸和类型。使用该方法能够复用旧 Bitmap 的内存从而避免给新 Bitmap 分配内存。通过复用生成的 Bitmap，新的内存大小可以通过 getByteCount() 方法获得。 由于 Bitmap 是复用的，所以它所映射的底层内存中还是原始图片的数据，所以 BitmapPool 将 Bitmap 返回给使用者前，还需要使用 Bitmap 的 eraseColor(Color.TRANSPARENT) 来擦除旧的数据。 LRU 算法实现BitmapPool 并没有使用 LruCache 来实现 LRU 功能，其内部使用 LinkedHashMap。而是自定义了一个数据结构 GroupedLinkedMap，其内部使用 HashMap，不同之处是其每个键对应的值是 LinkedEntry 对象，LinkedEntry 对象内部持有一个 ArrryList 来保存一组图片，并且持有 next 和 prev 引用指向其他 LinkedEntry，以构成一个双向链表，通过 makeTail() 和 makeHead() 方法来改变链表头尾的位置，从而实现 LRU 功能，其 LRU 算法针对的是对某尺寸的一组图片，而非某张图片。这样就能通过 Key 访问一组图片了。(其实本人觉得LruCache也可以实现，存的值类型是Arraylis 就好了) Glide 中的缓存机制算是介绍完了，本文先是从 Glide 的图片加载流程入手，还原出 Glide 缓存的整体设计。然后从 内存缓存、磁盘缓存、BitmapPool 三个方面分别介绍了各自的一些实现细节。由于本人水平有限，对 Glide 缓存机制的理解深度可能有些欠缺，如有发现文章中欠妥的地方欢迎指正。 感谢阅读。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Glide</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide源码解析（一）：加载流程]]></title>
    <url>%2F2017%2F04%2F27%2FGlide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[对于 Glide 相信大家都不陌生，它是 Google 员工 bumptech 开源的一款图片加载框架，因为其简单易用的 API ，强大的功能，优秀的内存管理被 Google 官方所推荐并且被广泛运用在 Google 的开源项目中。目前 Glide 、Picasso 和 Fresco 都是比较主流图片加载框架。 它们的使用场景基本都是重合的，而本人对 Glide 更为熟悉，所以选取 Glide 来进行深入学习，这系列文章作为学习的总结。选取的 Glide 版本是比较新的稳定版 3.7.0 。 本篇是源码解析的开篇，主要分析 Glide 加载图片的基本流程。在后续的专题中再对缓存机制、生命周期监听等细节进行详细分析。 预热为了预防直接扎进源码的海洋带来的各种不适，做一下热身还是很有必要的。我们先抛开源码，从感性角度理解 Glide 成功显示出一张图片，需要经过哪些过程,由什么角色完成，这些角色有机结合起来就是整个基本流程了。 数据源。即对数据来源的描述，要加载图片，当然需要告诉 Glide 从哪里获取了。它可以是 URL ，资源 ID 或者是一个文件。Glide 中称之为 Model。 从数据源中获取原始数据。一般是 InputStream ，Glide 中称之为 Data。负责从数据源中获取原始数据的角色称为 ModelLoader。 对原始数据解码。例如将 InputStream 解码为 Bitmap 或者 GifDrawable。解码后的资源称为 Resource。完成解码的角色称为 ResourceDecoder。 转码。Glide 除了能加载静图外，还能加载动图 Gif 。但是解码后静图类型 Bitmap 与 GifDrawable 并不统一。为了逻辑方便处理，Glide 会将 Bitmap 转码成 GlideBitmapDrawable。这样类型就能统一了，都是 GlideDrawable。负责转码的角色称为 Transcoder。 变换。根据图片设置的 ScaleType，做 FitCenter、CenterCrop 等转换。 在 Glide 中用 ResourceTranscoder 表示。 将图片显示到目标如 ImageView 上，Glide 将显示目标封装为 Target。 到这里已经从概念上梳理清楚 Glide 图片加载的大概流程了，这是抹去了大量细节的描述，但是记住这个流程在阅读源码时就能知道当前所在环节而不轻易迷失方向。 流程分析Glide 最基本的用法就是三步：with()再load()最后into()。下面从with()开始分析。 withwith()方法是 Glide 中的一组静态方法，有多个类型不同的重载方法： 1234567891011121314151617181920212223242526//RequestManager负责管理请求，具体是通过 Activity、Fragment的生命周期或网络连接的改变来智能地 start/stop/restart 请求。public static RequestManager with(Context context) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(context);&#125;public static RequestManager with(Activity activity) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(activity);&#125;public static RequestManager with(FragmentActivity activity) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(activity);&#125;@TargetApi(Build.VERSION_CODES.HONEYCOMB)public static RequestManager with(android.app.Fragment fragment) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(fragment);&#125;public static RequestManager with(Fragment fragment) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(fragment);&#125; 以上是with()的全部重载方法，with()方法可接受的参数类型很多，包括 Context、Activity、FragmentActivity和Fragment，这样就可以灵活的根据当前上下文进行选择。同时不同的参数会对图片加载的生命周期产生影响。这些重载方法的内部实现都比较简单，先调用RequestManagerRetriever类的静态get()方法，该方法返回RequestManagerRetriever的单例实现。然后调用该实例的get()重载方法，最终返回一个RequestManager。 RequestManager负责管理请求，具体是通过 Activity、Fragment的生命周期或网络连接的改变来智能地 start/stop/restart 请求。 下面看看 get()方法的内部逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154public class RequestManagerRetriever implements Handler.Callback &#123; /** The singleton instance of RequestManagerRetriever. */ private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever(); /** The top application level RequestManager. */ private volatile RequestManager applicationManager; /** * Retrieves and returns the RequestManagerRetriever singleton. */ public static RequestManagerRetriever get() &#123; return INSTANCE; &#125; private RequestManager getApplicationManager(Context context) &#123; // Either an application context or we&apos;re on a background thread. if (applicationManager == null) &#123; synchronized (this) &#123; if (applicationManager == null) &#123; // Normally pause/resume is taken care of by the fragment we add to the fragment or activity. // However, in this case since the manager attached to the application will not receive lifecycle // events, we must force the manager to start resumed using ApplicationLifecycle. applicationManager = new RequestManager(context.getApplicationContext(), new ApplicationLifecycle(), new EmptyRequestManagerTreeNode()); &#125; &#125; &#125; return applicationManager; &#125; public RequestManager get(Context context) &#123; if (context == null) &#123; throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;); &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123; if (context instanceof FragmentActivity) &#123; return get((FragmentActivity) context); &#125; else if (context instanceof Activity) &#123; return get((Activity) context); &#125; else if (context instanceof ContextWrapper) &#123; return get(((ContextWrapper) context).getBaseContext()); &#125; &#125; return getApplicationManager(context); &#125; public RequestManager get(FragmentActivity activity) &#123; //如果当前不是运行在主线程 if (Util.isOnBackgroundThread()) &#123; return get(activity.getApplicationContext()); &#125; else &#123; assertNotDestroyed(activity); FragmentManager fm = activity.getSupportFragmentManager(); return supportFragmentGet(activity, fm); &#125; &#125; public RequestManager get(Fragment fragment) &#123; if (fragment.getActivity() == null) &#123; throw new IllegalArgumentException(&quot;You cannot start a load on a fragment before it is attached&quot;); &#125; if (Util.isOnBackgroundThread()) &#123; return get(fragment.getActivity().getApplicationContext()); &#125; else &#123; FragmentManager fm = fragment.getChildFragmentManager(); return supportFragmentGet(fragment.getActivity(), fm); &#125; &#125; @TargetApi(Build.VERSION_CODES.HONEYCOMB) public RequestManager get(Activity activity) &#123; if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123; return get(activity.getApplicationContext()); &#125; else &#123; assertNotDestroyed(activity); android.app.FragmentManager fm = activity.getFragmentManager(); return fragmentGet(activity, fm); &#125; &#125; @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) private static void assertNotDestroyed(Activity activity) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1 &amp;&amp; activity.isDestroyed()) &#123; throw new IllegalArgumentException(&quot;You cannot start a load for a destroyed activity&quot;); &#125; &#125; @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) public RequestManager get(android.app.Fragment fragment) &#123; if (fragment.getActivity() == null) &#123; throw new IllegalArgumentException(&quot;You cannot start a load on a fragment before it is attached&quot;); &#125; if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; return get(fragment.getActivity().getApplicationContext()); &#125; else &#123; android.app.FragmentManager fm = fragment.getChildFragmentManager(); return fragmentGet(fragment.getActivity(), fm); &#125; &#125; @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) &#123; RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG); if (current == null) &#123; current = pendingRequestManagerFragments.get(fm); if (current == null) &#123; current = new RequestManagerFragment(); pendingRequestManagerFragments.put(fm, current); fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss(); handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget(); &#125; &#125; return current; &#125; @TargetApi(Build.VERSION_CODES.HONEYCOMB) RequestManager fragmentGet(Context context, android.app.FragmentManager fm) &#123; RequestManagerFragment current = getRequestManagerFragment(fm); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode()); current.setRequestManager(requestManager); &#125; return requestManager; &#125; SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm) &#123; SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag( FRAGMENT_TAG); if (current == null) &#123; current = pendingSupportRequestManagerFragments.get(fm); if (current == null) &#123; current = new SupportRequestManagerFragment(); pendingSupportRequestManagerFragments.put(fm, current); fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss(); ///在主线程中将刚添加的SupportRequestManagerFragment从pending中移除 handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget(); &#125; &#125; return current; &#125; RequestManager supportFragmentGet(Context context, FragmentManager fm) &#123; SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode()); current.setRequestManager(requestManager); &#125; return requestManager; &#125;&#125; get() 也有多个重载方法，不过实际上就是两种情况：Application类型和非Application类型。 当传入的参数是 Application 类型时，就调用 getApplicationManager() 方法获取一个 RequestManager 对象，这是最简单的一种情况，因为 Application 的生命周期也就是应用程序的生命周期，RequestManager 不需要特地去管理 Request 的生命周期。 当传入的参数是非 Application 类型时，先用当前的 Activity 或 Fragment 获取 FragmentManager。然后调用重载的 fragmentGet() 方法来获取 ResuqstManager。 fragmentGet() 方法的内部逻辑并不复杂，首先是调用 getRequestManagerFragment() 方法创建一个 RequestManagerFragment，然后创建一个 RequestManager 并且将两者绑定，最后返回 RequestManager 实例。 为什么要创建 RequestManagerFragment 呢？它和 RequestManager 是什么关系？其实是为了监听 Activity 的生命周期事件来达到管理图片加载的生命周期。一个 RequestManagerFragment 和一个 RequestManager 对应。RequestManagerFragment 是一个无界面的 Fragment ，通过 FragmentManager 添加到当前 Activity 或 Fragment 下，通过这样一个隐藏的 Fragment 就能知道当前 Activity 的生命周期了。而 RequestManager 在 RequestManagerFragment 中注册了回调接口。这样就能通过监听 Activity 或 Fragment 的 onStart 、onStop 、onDestory 回调来发起、暂停、取消加载请求。这是 Glide 中的巧妙设计之一。 with() 部分的源码就到此结束，没有复杂的逻辑，主要是为了获取一个能够监听生命周期的 RequestManager 对象。可见漫漫长路才开始了一小步。 load经过 with() 方法，我们获得了一个 RequestManager 对象。接下来我们看看 load() 方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Returns a request builder to load the given &#123;@link File&#125;. * * @see #fromFile() * @see #load(Object) * * @param file The File containing the image */ public DrawableTypeRequest&lt;File&gt; load(File file) &#123; return (DrawableTypeRequest&lt;File&gt;) fromFile().load(file); &#125; /** * Returns a request builder to load the given resource id. * * @see #fromResource() * @see #load(Object) * * @param resourceId the id of the resource containing the image */ public DrawableTypeRequest&lt;Integer&gt; load(Integer resourceId) &#123; return (DrawableTypeRequest&lt;Integer&gt;) fromResource().load(resourceId); &#125; /** * Returns a request builder to load the given &#123;@link java.lang.String&#125;. * signature. * * @see #fromString() * @see #load(Object) * * @param string A file path, or a uri or url handled by &#123;@link com.bumptech.glide.load.model.UriLoader&#125;. */ public DrawableTypeRequest&lt;String&gt; load(String string) &#123; return (DrawableTypeRequest&lt;String&gt;) fromString().load(string); &#125; /** * Returns a request builder to load the given &#123;@link Uri&#125;. * * @see #fromUri() * @see #load(Object) * * @param uri The Uri representing the image. Must be of a type handled by * &#123;@link com.bumptech.glide.load.model.UriLoader&#125;. */ public DrawableTypeRequest&lt;Uri&gt; load(Uri uri) &#123; return (DrawableTypeRequest&lt;Uri&gt;) fromUri().load(uri); &#125; load() 也有多个重载方法，能接受文件、资源ID、字符串和 Uri 作为输入进而加载图片。这里我就选取最常见的用 URL 字符串输入来分析。只有简短的一行代码，链式调用了fromString() 方法和 load() 方法。先来看看 fromString() 方法 1234567891011121314151617181920public DrawableTypeRequest&lt;String&gt; fromString() &#123; return loadGeneric(String.class);&#125;private &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) &#123; ///对于 string,int,integer,file,uri ,glide对每种modelclass都注册了将其转化为InputStream和ParcelFileDescriptor的ModelLoaderFactory ///从注册的ModelLoaderFactory中查找string -&gt; stream 的 modelloader 得到StreamStringLoader ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context); ///从注册的ModelLoaderFactory查找 string -&gt; filedescriptor 的modelloader 得到FileDescriptorStringLoader ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader = Glide.buildFileDescriptorModelLoader(modelClass, context); if (modelClass != null &amp;&amp; streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) &#123; throw new IllegalArgumentException(&quot;Unknown type &quot; + modelClass + &quot;. You must provide a Model of a type for&quot; + &quot; which there is a registered ModelLoader, if you are using a custom model, you must first call&quot; + &quot; Glide#register with a ModelLoaderFactory for your custom model class&quot;); &#125; return optionsApplier.apply( new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,glide, requestTracker, lifecycle, optionsApplier));&#125; fromString() 方法内部调用了 loadGeneric() 方法，loadGeneric() 方法返回了一个 DrawableTypeRequest 对象。 DrawableTypeRequest 的继承关系如下 可见它负责创建加载请求，同时也代表一个加载 Drawable 的请求。现在回到上段代码，看看它是如何创建出来的。 第一步，先是调用了 Glide 的静态方法 buildStreamModelLoader() 和 buildFileDescriptorModelLoader() 来获得两个 ModelLoader。回想一下预热部分的内容，ModelLoader 是负责从数据源中获取原始数据的，这里分别获得了从 String 表示的 URL 中取得 InputStream 和 ParcelFileDescriptor 的 ModelLoader。 实际上，Glide 在初始化的时候,对于每种类型的输入：String、int、Integer、File、Uri，都注册了能够将它们转化为 InputStream 和 ParcelFileDescriptor 的 ModelLoader，保存在HashMap中。这两个 buildxxxModelLoader() 方法实际上就是从 HashMap 中获取对应的 ModelLoader。在当前情景下，获取到的是 StreamStringLoader 和 FileDescriptorStringLoader。 第二步，用刚刚获取的 StreamStringLoader 和 FileDescriptorStringLoader 作为构造参数来创建 DrawableTypeRequest。还有其他一些参数，这里暂且先不关注。 回到 RequestManager 的 load() 方法，接下来执行 fromString() 返回的 DrawableTypeRequest 的 load() 方法。DrawableTypeRequest 没有 load() 方法，因此实际上执行的是其父类 DrawableRequestBuilder 的 load() 方法。 123456789101112131415===DrawableRequestBuilder.java===@Overridepublic DrawableRequestBuilder&lt;ModelType&gt; load(ModelType model) &#123; super.load(model); return this;&#125;===GenericRequestBuilder.java===public GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; load(ModelType model) &#123; this.model = model; isModelSet = true; return this;&#125; 只是做了简单的赋值操作，这里就不多做解释了。 第二步 load() 至此也结束了，目前我们得到了一个 DrawableTypeRequest 对象。第三步 into() 将围绕这个对象展开。 into接下来接着看 DrawableTypeRequest 的 into() 方法。 1234@Overridepublic Target&lt;GlideDrawable&gt; into(ImageView view) &#123; return super.into(view);&#125; 真正的逻辑在其父类 GenericRequestBuilder 中。 1234567891011121314151617181920212223242526272829303132333435/** * Sets the &#123;@link ImageView&#125; the resource will be loaded into, cancels any existing loads into the view, and frees * any resources Glide may have previously loaded into the view so they may be reused. * * @see Glide#clear(android.view.View) * * @param view The view to cancel previous loads for and load the new resource into. * @return The &#123;@link com.bumptech.glide.request.target.Target&#125; used to wrap the given &#123;@link ImageView&#125;. */public Target&lt;TranscodeType&gt; into(ImageView view) &#123; Util.assertMainThread(); if (view == null) &#123; throw new IllegalArgumentException(&quot;You must pass in a non null View&quot;); &#125; if (!isTransformationSet &amp;&amp; view.getScaleType() != null) &#123; switch (view.getScaleType()) &#123; case CENTER_CROP: //导致transformation中保存一个类型为centerCrop的transformation,并且isTransformationSet设为true applyCenterCrop(); break; case FIT_CENTER: case FIT_START: case FIT_END: applyFitCenter(); break; //$CASES-OMITTED$ default: // Do nothing. &#125; &#125; ///transcodeClass用来标记imageview的使用bitmap还是drawable还是glidedrawable。返回不同实例的ImageViewTarget return into(glide.buildImageViewTarget(view, transcodeClass));&#125; 首先 Glide 根据 ImageView 的 ScaleType 来对图片进行相应的变换。这里选取 CENTER_CROP 的场景作为例子进行分析。来看看 applyCenterCrop() 方法。 applyCenterCrop() 的实现在具体的子类中，在当前场景下就是 DrawableTypeRequest。 1234567891011121314151617181920212223242526272829===DrawableTypeRequest.java===@Override void applyCenterCrop() &#123; centerCrop(); &#125; public DrawableRequestBuilder&lt;ModelType&gt; centerCrop() &#123; return transform(glide.getDrawableCenterCrop()); &#125; public DrawableRequestBuilder&lt;ModelType&gt; transform(Transformation&lt;GifBitmapWrapper&gt;... transformation) &#123; super.transform(transformation); return this; &#125; ===GenericRequestBuilder.java=== public GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; transform( Transformation&lt;ResourceType&gt;... transformations) &#123; isTransformationSet = true; if (transformations.length == 1) &#123; transformation = transformations[0]; &#125; else &#123; transformation = new MultiTransformation&lt;ResourceType&gt;(transformations); &#125; return this; &#125; 嵌套比较多，我抽取出了上面的相关方法。 在 DrawableTypeRequest 的 centerCrop() 方法中调用了 Glide 的 glide.getDrawableCenterCrop() 获取一个 Transformation 实例。预热部分提到，Transformation 负责对图片进行 CenterCrop、FitCenter 等转化。此处会获取到一个 GifBitmapWrapperTransformation,其内部封装了对 Bitmap 执行转化的 BitmapTransformation 和一个对 GifDrawable 执行变换的 GifDrawableTransformation。 经过层层嵌套，最终会执行父类 GenericRequestBuilder 的 transform() 方法，该方法将 isTransformationSet 置为 true，并且将 Transformation 实例保存到 transformation 变量中。可见这里只是做了相关的赋值操作，真正的图片变换将在后面合适的时机进行。 回到 GenericRequestBuilder 的 into() 方法，记录下该图片需要进行的转化之后，调用了 Glide 的 buildImageViewTarget() 来构建一个 ImageViewTarget，然后使用 ImageViewTarget 作为参数执行 into() 方法。 Target 是一个接口，Glide 将可以接收图片的目标封装成一个 Target 对象，并且 Target 包含 onLoadStarted、onResourceReady、onLoadCleared、onLoadFailed 等方法来显示不同的内容。 我们接着看看 buildImageViewTarget() 方法 12345678910111213141516171819202122232425 ===Glide.java=== &lt;R&gt; Target&lt;R&gt; buildImageViewTarget(ImageView imageView, Class&lt;R&gt; transcodedClass) &#123; return imageViewTargetFactory.buildTarget(imageView, transcodedClass); &#125; === ImageViewTargetFactory.java=== public class ImageViewTargetFactory &#123; //这个class参数其实基本上只有两种情况，如果你在使用Glide加载图片的时候调用了asBitmap()方法， //那么这里就会构建出BitmapImageViewTarget对象，否则的话构建的都是GlideDrawableImageViewTarget对象。 @SuppressWarnings(&quot;unchecked&quot;) public &lt;Z&gt; Target&lt;Z&gt; buildTarget(ImageView view, Class&lt;Z&gt; clazz) &#123; if (GlideDrawable.class.isAssignableFrom(clazz)) &#123; return (Target&lt;Z&gt;) new GlideDrawableImageViewTarget(view); &#125; else if (Bitmap.class.equals(clazz)) &#123; return (Target&lt;Z&gt;) new BitmapImageViewTarget(view); &#125; else if (Drawable.class.isAssignableFrom(clazz)) &#123; return (Target&lt;Z&gt;) new DrawableImageViewTarget(view); &#125; else &#123; throw new IllegalArgumentException(&quot;Unhandled class: &quot; + clazz + &quot;, try .as*(Class).transcode(ResourceTranscoder)&quot;); &#125; &#125;&#125; 返回的 Target 具体实例取决于 transcodedClass 参数，该参数由 DrawableTypeRequest 传入，具体来说就是 GlideDrawable.class。而如果你在 Glide.with().load() 之后加上了 asBitmap()，将得到一个 BitmapTypeRequest,那么 transcodedClass 参数将是 Bitmap.class。如果加上了 asGif() ,将得到一个 GifTypeRequest，那么 transcodedClass 参数将是 GifDrawable。实际上他们都是 GenericRequestBuilder 的子类，关系如下： 简单来说，默认情况下 buildImageViewTarget 将返回一个 GlideDrawableImageViewTarget 实例，除非你调用了 asBitmap(),那么将返回一个 BitmapImageViewTarget 实例。在当前情景下，我们获取到的是前者。 回到 GenericRequestBuilder 的 into() 方法，刚刚我们构建了一个 GlideDrawableImageViewTarget 对象，接下来它将作为参数来执行重载的 into() 方法。 12345678910111213141516171819202122232425//清除target绑定的旧request,新建一个request并绑定到target。将request传递到requestTracker的runRequest方法中public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) &#123; Util.assertMainThread(); if (target == null) &#123; throw new IllegalArgumentException(&quot;You must pass in a non null Target&quot;); &#125; if (!isModelSet) &#123; throw new IllegalArgumentException(&quot;You must first set a model (try #load())&quot;); &#125; Request previous = target.getRequest(); if (previous != null) &#123; previous.clear();///回收资源,设置状态,设置placeholder requestTracker.removeRequest(previous);///意味着就request不再受生命周期回调影响 previous.recycle();///成员属性置null,回收到REQUEST_POOL,以供复用 &#125; Request request = buildRequest(target); target.setRequest(request); lifecycle.addListener(target); requestTracker.runRequest(request); return target;&#125; 这段代码主要是构建了一个 Request 对象然后执行。首先 target.getRequest() 取出与 target 对象绑定的 Request 对象。Glide 通过 View 的 setTag() 方法将特定的 View 和其对应的图片加载请求绑定在一起。这样做的好处是能够容易地判断 Target 所封装的 View 是否被复用，复用时先取消之前的请求，避免了不必要的请求，也能防止图片错位。如果没有之前绑定的请求，说明该 View 没有被复用，那么调用 buildRequest() 创建一个 Request 对象，然后通过 requestTracker.runRequest 交给 RequestTracker 去执行。 下面先看下 Request 是如何构建出来的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private Request buildRequest(Target&lt;TranscodeType&gt; target) &#123; if (priority == null) &#123; priority = Priority.NORMAL; &#125; return buildRequestRecursive(target, null);&#125;private Request buildRequestRecursive(Target&lt;TranscodeType&gt; target, ThumbnailRequestCoordinator parentCoordinator) &#123; if (thumbnailRequestBuilder != null) &#123; if (isThumbnailBuilt) &#123; throw new IllegalStateException(&quot;You cannot use a request as both the main request and a thumbnail, &quot; + &quot;consider using clone() on the request(s) passed to thumbnail()&quot;); &#125; // Recursive case: contains a potentially recursive thumbnail request builder. if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) &#123; thumbnailRequestBuilder.animationFactory = animationFactory; &#125; if (thumbnailRequestBuilder.priority == null) &#123; thumbnailRequestBuilder.priority = getThumbnailPriority(); &#125; if (Util.isValidDimensions(overrideWidth, overrideHeight) &amp;&amp; !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth, thumbnailRequestBuilder.overrideHeight)) &#123; thumbnailRequestBuilder.override(overrideWidth, overrideHeight); &#125; ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator); Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator); // Guard against infinite recursion. isThumbnailBuilt = true; // Recursively generate thumbnail requests. Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator); isThumbnailBuilt = false; coordinator.setRequests(fullRequest, thumbRequest); return coordinator; &#125; else if (thumbSizeMultiplier != null) &#123; // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse. ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator); Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator); Request thumbnailRequest = obtainRequest(target, thumbSizeMultiplier, getThumbnailPriority(), coordinator); coordinator.setRequests(fullRequest, thumbnailRequest); return coordinator; &#125; else &#123; // Base case: no thumbnail. ///parentCoordinator是null return obtainRequest(target, sizeMultiplier, priority, parentCoordinator); &#125;&#125; buildRequest() 方法内部调用了 buildRequestRecursive() 方法。buildRequestRecursive() 方法中有三个分支，前两个分支与略缩图有关，当前情景下会进入到第三个分支，仅仅是调用了 obtainRequest() 方法。 123456789101112131415161718192021222324252627private Request obtainRequest(Target&lt;TranscodeType&gt; target, float sizeMultiplier, Priority priority, RequestCoordinator requestCoordinator) &#123; return GenericRequest.obtain( loadProvider, model, signature, context, priority, target, sizeMultiplier, placeholderDrawable, placeholderId, errorPlaceholder, errorId, fallbackDrawable, fallbackResource, requestListener, requestCoordinator, glide.getEngine(), transformation, transcodeClass, isCacheable, animationFactory, overrideWidth, overrideHeight, diskCacheStrategy);&#125; obtainRequest() 方法内部又去调用了 GenericRequest 静态的 obtain() 方法来获取 Request。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static &lt;A, T, Z, R&gt; GenericRequest&lt;A, T, Z, R&gt; obtain( LoadProvider&lt;A, T, Z, R&gt; loadProvider, A model, Key signature, Context context, Priority priority, Target&lt;R&gt; target, float sizeMultiplier, Drawable placeholderDrawable, int placeholderResourceId, Drawable errorDrawable, int errorResourceId, Drawable fallbackDrawable, int fallbackResourceId, RequestListener&lt;? super A, R&gt; requestListener, RequestCoordinator requestCoordinator, Engine engine, Transformation&lt;Z&gt; transformation, Class&lt;R&gt; transcodeClass, boolean isMemoryCacheable, GlideAnimationFactory&lt;R&gt; animationFactory, int overrideWidth, int overrideHeight, DiskCacheStrategy diskCacheStrategy) &#123; @SuppressWarnings(&quot;unchecked&quot;) GenericRequest&lt;A, T, Z, R&gt; request = (GenericRequest&lt;A, T, Z, R&gt;) REQUEST_POOL.poll(); if (request == null) &#123; request = new GenericRequest&lt;A, T, Z, R&gt;(); &#125; request.init(loadProvider, model, signature, context, priority, target, sizeMultiplier, placeholderDrawable, placeholderResourceId, errorDrawable, errorResourceId, fallbackDrawable, fallbackResourceId, requestListener, requestCoordinator, engine, transformation, transcodeClass, isMemoryCacheable, animationFactory, overrideWidth, overrideHeight, diskCacheStrategy); return request;&#125; 如果没有可复用的 Request,那么将会创建一个 GenericRequest 实例，它是 Request 接口的实现。然后调用了该实例的 init() 方法，里面主要是做一些赋值操作，就不展开了。 现在我们拥有了一个 GenericRequest 实例，接下来它将交给 RequestTracker 的 runRequest() 方法执行。 12345678public void runRequest(Request request) &#123; requests.add(request); if (!isPaused) &#123; request.begin(); &#125; else &#123; pendingRequests.add(request); &#125;&#125; RequestTracker 调用了 Request 实例的 begin() 方法 1234567891011121314151617181920212223242526public void begin() &#123; startTime = LogTime.getLogTime(); if (model == null) &#123; onException(null); return; &#125; status = Status.WAITING_FOR_SIZE; if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123; ///如果使用了override() API为图片指定了一个固定的宽高 onSizeReady(overrideWidth, overrideHeight); &#125; else &#123; //没有指定 //内部使用Determiner先尝试获取view.getWidth/view.getHight,如果两者都为0,那么检查layoutparam是否为空,如果也为空,就在view的ViewTreeObserver上添加OnPreDrawListener,在回调方法中再次去检查。 // 在计算完之后，它也会调用onSizeReady()方法 target.getSize(this); &#125; ///设置占位图 if (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123; target.onLoadStarted(getPlaceholderDrawable()); &#125; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(&quot;finished run method in &quot; + LogTime.getElapsedMillis(startTime)); &#125; &#125; 上面这段代码主要尝试去确定当前请求的图片大小，同时给 Target 设置占位图。 当前图片请求的大小是否已经指定取决于是否使用了 override() 方法，如果已经指定则调用 onSizeReady() 做进一步操作，如果还没有指定，则调用 getSize() 方法来确定 ImageView 的实际大小。getSize() 方法内部使用 SizeDeterminer 辅助类，依次从 view.getWidth/view.getHight、layoutparam 获取，如果还不能确定，说明该 View 还没有 measure 完毕。那么就在该 View 的ViewTreeObserver 添加 OnPreDrawListener，当整个 view tree measure 完毕即将 draw 时会收到 onPreDraw() 方法回调，这时再重新确定 View 的大小。确定好大小后会调用 onSizeReady() 方法。 同时，会调用 getPlaceholderDrawable() 方法获取占位图 然后调用 Target 的 onLoadStarted() 方法来设置占位图，我们来看一下内部细节 123456789101112131415===GenericRequest.java===private Drawable getPlaceholderDrawable() &#123; if (placeholderDrawable == null &amp;&amp; placeholderResourceId &gt; 0) &#123; placeholderDrawable = context.getResources().getDrawable(placeholderResourceId); &#125; return placeholderDrawable;&#125;===ImageViewTarget.java===@Overridepublic void onLoadStarted(Drawable placeholder) &#123; view.setImageDrawable(placeholder);&#125; 最终会调用 ImageView 对象的 setImageDrawable() 方法，这就是通过 placeholder() 设置占位图的原理。上面 begin() 代码中的onException(null) 也是类似，看官们可以自行研究。 上面刚才说到确定图片大小之后会调用 onSizeReady() 方法，下面我们来看看它的内部逻辑 12345678910111213141516171819202122232425262728293031323334public void onSizeReady(int width, int height) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(&quot;Got onSizeReady in &quot; + LogTime.getElapsedMillis(startTime)); &#125; if (status != Status.WAITING_FOR_SIZE) &#123; return; &#125; status = Status.RUNNING; width = Math.round(sizeMultiplier * width); height = Math.round(sizeMultiplier * height); ///loadProvider是一个FixedLoadProvider，返回ImageVideoModelLoader ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader(); ///返回ImageVideoFetcher,其封装了StreamStringLoader和FileDescriptorStringlLoader的fetcher final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height); if (dataFetcher == null) &#123; onException(new Exception(&quot;Failed to load model: \&apos;&quot; + model + &quot;\&apos;&quot;)); return; &#125; ///GifBitmapWrapperDrawableTranscoder ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder(); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(&quot;finished setup for calling load in &quot; + LogTime.getElapsedMillis(startTime)); &#125; loadedFromMemoryCache = true; loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder, priority, isMemoryCacheable, diskCacheStrategy, this); loadedFromMemoryCache = resource != null; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(&quot;finished onSizeReady in &quot; + LogTime.getElapsedMillis(startTime)); &#125;&#125; 这段代码主要从 loadProvider 获取了 ModelLoader 和 ResourceTranscoder，然后传进 Engine 的 load() 方法中。 要读懂这段代码首先要明白 loadProvider 是什么东西？从何而来？经过层层回溯会发现，loadProvider 是从 DrawableTypeRequest 的构造函数传入的，我们回头看一下 DrawableTypeRequest 的构造函数 1234567891011DrawableTypeRequest(Class&lt;ModelType&gt; modelClass, ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader, ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Context context, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) &#123; super(context, modelClass, buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class, GlideDrawable.class, null), glide, requestTracker, lifecycle); this.streamModelLoader = streamModelLoader; this.fileDescriptorModelLoader = fileDescriptorModelLoader; this.optionsApplier = optionsApplier; &#125; DrawableTypeRequest 的构造函数中 调用 buildProvider 创建了一个 FixedLoadProvider，并将它作为参数调用了父类的构造函数，我们来看一下 buildProvider（） 12345678910111213141516171819202122232425///A代表Model类型:String Z代表Resource类型:GifBitmapWrapper R代表转码后类型：GlideDrawableprivate static &lt;A, Z, R&gt; FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt; buildProvider(Glide glide, ModelLoader&lt;A, InputStream&gt; streamModelLoader, ModelLoader&lt;A, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Class&lt;Z&gt; resourceClass, Class&lt;R&gt; transcodedClass, ResourceTranscoder&lt;Z, R&gt; transcoder) &#123; if (streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) &#123; return null; &#125; if (transcoder == null) &#123; ///Glide 为 GifBitmapWrapper -&gt; GlideDrawable 和 Bitmap -&gt; GlideBitmapDrawable 都注册了ResourceTranscoder ///获取负责将 GifBitmapWrapper 转码成 GlideDrawable 的 ResourceTranscoder,这里获取到GifBitmapWrapperDrawableTranscoder transcoder = glide.buildTranscoder(resourceClass, transcodedClass); &#125; /// DataLoadProvider 用于图片编解码,此处获取 ImageVideoWrapper 与 GifBitmapWrapper 编解码的 DataLoadProvider // 得到的实例是ImageVideoGifDrawableLoadProvider DataLoadProvider&lt;ImageVideoWrapper, Z&gt; dataLoadProvider = glide.buildDataProvider(ImageVideoWrapper.class, resourceClass); ///封装了 StreamStringLoader 和 FileDescriptorStringLoader ImageVideoModelLoader&lt;A&gt; modelLoader = new ImageVideoModelLoader&lt;A&gt;(streamModelLoader, fileDescriptorModelLoader); ///这个也就是 onSizeReady() 方法中的 loadProvider return new FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt;(modelLoader, transcoder, dataLoadProvider);&#125; 这段代码已经附上了比较详细的注释。首先说明一下，DataLoadProvider 是一个接口，接口声明如下 123456789101112131415161718192021222324252627282930/** * A load provider that provides the necessary encoders and decoders to decode a specific type of resource from a * specific type of data. * * @param &lt;T&gt; The type of data the resource will be decoded from. * @param &lt;Z&gt; The type of resource that will be decoded. */public interface DataLoadProvider&lt;T, Z&gt; &#123; /** * Returns the &#123;@link com.bumptech.glide.load.ResourceDecoder&#125; to use to decode the resource from the disk cache. */ ResourceDecoder&lt;File, Z&gt; getCacheDecoder(); /** * Returns the &#123;@link com.bumptech.glide.load.ResourceDecoder&#125; to use to decode the resource from the original data. */ ResourceDecoder&lt;T, Z&gt; getSourceDecoder(); /** * Returns the &#123;@link com.bumptech.glide.load.Encoder&#125; to use to write the original data to the disk cache. */ Encoder&lt;T&gt; getSourceEncoder(); /** * Returns the &#123;@link com.bumptech.glide.load.ResourceEncoder&#125; to use to write the decoded and transformed resource * to the disk cache. */ ResourceEncoder&lt;Z&gt; getEncoder();&#125; 一个 DataLoadProvider 实例负责提供 Data 和 Resource 之间的编解码，解码表示从 Date 转化为 Resource 的过程，编码表示将 Date 或者 Resource 持久化为本地文件的过程，以实现磁盘缓存。所以 DataLoadProvider 提供了四个方法： getCacheDecoder getSourceDecoder getSourceEncoder getEncoder 返回类型 ResourceDecoder ResourceDecoder Encoder ResourceEncoder 转化前 File Data Data Resource 转化后 Resource Resource File File 这样一个 DataLoadProvider 实例就包办 Resource 的解码和缓存了。 Glide 提供了丰富的 DataLoadProvider 实例来实现各种类型之间的编解码  这里还要提一个接口 LoadProvider，它继承了 DataLoadProvider 接口，并新增了两个方法 12345678910111213public interface LoadProvider&lt;A, T, Z, R&gt; extends DataLoadProvider&lt;T, Z&gt; &#123; /** * Returns the &#123;@link com.bumptech.glide.load.model.ModelLoader&#125; to convert from the given model to a data type. */ ModelLoader&lt;A, T&gt; getModelLoader(); /** * Returns the &#123;@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder&#125; to convert from the decoded * and transformed resource into the transcoded resource. */ ResourceTranscoder&lt;Z, R&gt; getTranscoder();&#125; LoadProvider 接口新增了获取 ModelLoader 和 ResourceTranscoder 的两个方法。我们当前讨论的主角 FixedLoadProvider 就是 LoadProvider 的实例，它是多个 DataLoadProvider 实例的顶层封装 ，它与大部分的 DataLoadProvider 实例有着紧密的联系，它们之间的依赖关系如下 所以说，FixLoadProvider 提供了图片原始数据的获取、解码、编码、转码的一条龙服务！ 回到 buildProvider() 那段代码，buildProvider() 方法中获取了 GifBitmapWrapperDrawableTranscoder 、ImageVideoGifDrawableLoadProvider 和 ImageVideoModelLoader，然后作为参数构建了一个 FixLoadProvider，这个也就是 onSizeReady() 方法中的 loadProvider 实例。 了解了 FixLoadProvider 之后，我们就可以回过头重新看看 onSizeReady() 方法了，这里重新贴一下 12345678910111213141516171819202122232425262728293031323334public void onSizeReady(int width, int height) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(&quot;Got onSizeReady in &quot; + LogTime.getElapsedMillis(startTime)); &#125; if (status != Status.WAITING_FOR_SIZE) &#123; return; &#125; status = Status.RUNNING; width = Math.round(sizeMultiplier * width); height = Math.round(sizeMultiplier * height); ///loadProvider是一个FixedLoadProvider，返回ImageVideoModelLoader ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader(); ///返回ImageVideoFetcher,其封装了StreamStringLoader和FileDescriptorStringlLoader的fetcher final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height); if (dataFetcher == null) &#123; onException(new Exception(&quot;Failed to load model: \&apos;&quot; + model + &quot;\&apos;&quot;)); return; &#125; ///GifBitmapWrapperDrawableTranscoder ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder(); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(&quot;finished setup for calling load in &quot; + LogTime.getElapsedMillis(startTime)); &#125; loadedFromMemoryCache = true; loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder, priority, isMemoryCacheable, diskCacheStrategy, this); loadedFromMemoryCache = resource != null; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(&quot;finished onSizeReady in &quot; + LogTime.getElapsedMillis(startTime)); &#125;&#125; 这里从 loadProvider 获取了刚刚提到的 ImageVideoModelLoader 和 GifBitmapWrapperDrawableTranscoder，还有从 ImageVideoModelLoader 中获取一个 DataFetcher 实例。getResourceFetcher() 是 ModelLoader 接口的唯一一个方法，返回一个真正执行原始数据获取的一个 DataFetcher 实例。最后 onSizeReady() 将一系列值传进 Engin 的 load() 方法中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Responsible for starting loads and managing active and cached resources. */public class Engine implements EngineJobListener, MemoryCache.ResourceRemovedListener, EngineResource.ResourceListener &#123; public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher, DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder, Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) &#123; Util.assertMainThread(); long startTime = LogTime.getLogTime(); final String id = fetcher.getId(); EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(), loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(), transcoder, loadProvider.getSourceEncoder()); EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable); if (cached != null) &#123; cb.onResourceReady(cached); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key); &#125; return null; &#125; EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable); if (active != null) &#123; cb.onResourceReady(active); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key); &#125; return null; &#125; EngineJob current = jobs.get(key); if (current != null) &#123; current.addCallback(cb); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key); &#125; return new LoadStatus(cb, current); &#125; ///EngineJob的主要作用就是用来开启线程的，为后面的异步加载图片做准备 EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable); DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation, transcoder, diskCacheProvider, diskCacheStrategy, priority); EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority); jobs.put(key, engineJob); ///将GenericRequest的回调接口交给enginejob engineJob.addCallback(cb); ///实际上就是让EngineRunnable的run()方法在子线程当中执行 engineJob.start(runnable); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Started new load&quot;, startTime, key); &#125; return new LoadStatus(cb, engineJob); &#125;&#125; loadFromCache() 和 loadFromActiveResources() 与内存缓存有关，不是本文的重点，我们关注最下面这段就可以了。这里分别创建了 EngineJob 和 DecodeJob，并用来构建 EngineRunnable。 EngineJob 负责统一管理加载请求的 ResourceCallback，EngineJob 本身也实现了 ResourceCallback 接口，当加载请求完成时 EngineRunnable 回调 EngineJob 的 onResourceReady() 方法，EngineJob 在分发给所有的监听者。 DecodeJob 的工作特别繁重，负责了 Resource 的所有解码工作，包括从 Data 解码和从缓存解码，同时承担了解码之后的转换和转码工作。 最后把 EngineRunnable 交给 Engine 的 start() 方法执行。 1234public void start(EngineRunnable engineRunnable) &#123; this.engineRunnable = engineRunnable; future = diskCacheService.submit(engineRunnable); &#125; 这里交给了线程池去处理，那么 EngineRunnable 的 run() 方法将在子线程中运行。 1234567891011121314151617181920212223242526272829303132333435class EngineRunnable implements Runnable, Prioritized &#123; @Override public void run() &#123; if (isCancelled) &#123; return; &#125; Exception exception = null; Resource&lt;?&gt; resource = null; try &#123; ///最后会得到Resource&lt;GlideDrawable&gt;实例 resource = decode(); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, &quot;Exception decoding&quot;, e); &#125; exception = e; &#125; if (isCancelled) &#123; if (resource != null) &#123; resource.recycle(); &#125; return; &#125; if (resource == null) &#123; /// 第一次走decode()尝试从磁盘获取,失败后会走这里。重新进入decode onLoadFailed(exception); &#125; else &#123; onLoadComplete(resource); &#125; &#125;&#125; 这段代码的重点是 decode() 方法，它将返回一个 Resource 实例对象，那么我们看看它的内部逻辑 123456789private Resource&lt;?&gt; decode() throws Exception &#123; if (isDecodingFromCache()) &#123; ///从磁盘缓存中decode图片,第一次会走这 return decodeFromCache(); &#125; else &#123; ///从源中decode图片,第二次会走这 return decodeFromSource(); &#125; &#125; 第一次进入该方法时 isDecodingFromCache() 返回 true，Glide 会尝试从磁盘缓存解码图片。本文关注的重点是图片加载的基本流程，怎么从无到有加载一张图片，我们来看下 decodeFromSource() 方法 123private Resource&lt;?&gt; decodeFromSource() throws Exception &#123; return decodeJob.decodeFromSource();&#125; 这里交给 DecodeJob 去处理 123456public Resource&lt;Z&gt; decodeFromSource() throws Exception &#123; ///返回Resource&lt;GifBitmapWrapper&gt; Resource&lt;T&gt; decoded = decodeSource(); ///返回了Resource&lt;GlideDrawable&gt;,统一了静态图和动图类型 return transformEncodeAndTranscode(decoded);&#125; decodeFromSource() 方法的工作分为两部分：从数据源获取图片，返回封装类 Resource；转化和转码。虽然看似简单，但是每一步都包含大量的逻辑。先看看 decodeSource() 12345678910111213141516171819private Resource&lt;T&gt; decodeSource() throws Exception &#123; Resource&lt;T&gt; decoded = null; try &#123; long startTime = LogTime.getLogTime(); ///ImageVideoFetcher,返回一个ImageVideoWrapper final A data = fetcher.loadData(priority); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Fetched data&quot;, startTime); &#125; if (isCancelled) &#123; return null; &#125; ///返回 Resource&lt;GifBitmapWrapper&gt; decoded = decodeFromSourceData(data); &#125; finally &#123; fetcher.cleanup(); &#125; return decoded;&#125; 这里首先使用 DataFetcher 的 loadData() 获取图片的原始数据，InputStream 或者是 ParcelFileDescriptor。然后调用 decodeFromSourceData(）进行解码。这里的 DataFetcher 实例其实就是 FixLoaderProvider 提供的 ModelLoader 所提供的 DataFetcher 实例，实际上是 ImageVideoFetcher 类型，我们看看它的 loadData() 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445static class ImageVideoFetcher implements DataFetcher&lt;ImageVideoWrapper&gt; &#123; private final DataFetcher&lt;InputStream&gt; streamFetcher; private final DataFetcher&lt;ParcelFileDescriptor&gt; fileDescriptorFetcher; public ImageVideoFetcher(DataFetcher&lt;InputStream&gt; streamFetcher, DataFetcher&lt;ParcelFileDescriptor&gt; fileDescriptorFetcher) &#123; this.streamFetcher = streamFetcher; this.fileDescriptorFetcher = fileDescriptorFetcher; &#125; @SuppressWarnings(&quot;resource&quot;) // @see ModelLoader.loadData @Override public ImageVideoWrapper loadData(Priority priority) throws Exception &#123; InputStream is = null; if (streamFetcher != null) &#123; try &#123; ///HttpUrlFetcher is = streamFetcher.loadData(priority); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, &quot;Exception fetching input stream, trying ParcelFileDescriptor&quot;, e); &#125; if (fileDescriptorFetcher == null) &#123; throw e; &#125; &#125; &#125; ParcelFileDescriptor fileDescriptor = null; if (fileDescriptorFetcher != null) &#123; try &#123; fileDescriptor = fileDescriptorFetcher.loadData(priority); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, &quot;Exception fetching ParcelFileDescriptor&quot;, e); &#125; if (is == null) &#123; throw e; &#125; &#125; &#125; ///用来封装服务器返回的InputStream return new ImageVideoWrapper(is, fileDescriptor); &#125; &#125; ImageVideoFetcher 内部的 streamFetcher 实际上是一个 HttpUrlFetcher 对象，调用了它的 loadData() 获取 InputStream 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class HttpUrlFetcher implements DataFetcher&lt;InputStream&gt; &#123; @Override public InputStream loadData(Priority priority) throws Exception &#123; return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders()); &#125; private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map&lt;String, String&gt; headers) throws IOException &#123; if (redirects &gt;= MAXIMUM_REDIRECTS) &#123; throw new IOException(&quot;Too many (&gt; &quot; + MAXIMUM_REDIRECTS + &quot;) redirects!&quot;); &#125; else &#123; // Comparing the URLs using .equals performs additional network I/O and is generally broken. // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html. try &#123; if (lastUrl != null &amp;&amp; url.toURI().equals(lastUrl.toURI())) &#123; throw new IOException(&quot;In re-direct loop&quot;); &#125; &#125; catch (URISyntaxException e) &#123; // Do nothing, this is best effort. &#125; &#125; urlConnection = connectionFactory.build(url); for (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123; urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue()); &#125; urlConnection.setConnectTimeout(2500); urlConnection.setReadTimeout(2500); urlConnection.setUseCaches(false); urlConnection.setDoInput(true); // Connect explicitly to avoid errors in decoders if connection fails. urlConnection.connect(); if (isCancelled) &#123; return null; &#125; final int statusCode = urlConnection.getResponseCode(); if (statusCode / 100 == 2) &#123; return getStreamForSuccessfulRequest(urlConnection); &#125; else if (statusCode / 100 == 3) &#123; String redirectUrlString = urlConnection.getHeaderField(&quot;Location&quot;); if (TextUtils.isEmpty(redirectUrlString)) &#123; throw new IOException(&quot;Received empty or null redirect url&quot;); &#125; URL redirectUrl = new URL(url, redirectUrlString); return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers); &#125; else &#123; if (statusCode == -1) &#123; throw new IOException(&quot;Unable to retrieve response code from HttpUrlConnection.&quot;); &#125; throw new IOException(&quot;Request failed &quot; + statusCode + &quot;: &quot; + urlConnection.getResponseMessage()); &#125; &#125; private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection) throws IOException &#123; if (TextUtils.isEmpty(urlConnection.getContentEncoding())) &#123; int contentLength = urlConnection.getContentLength(); stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength); &#125; else &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, &quot;Got non empty content encoding: &quot; + urlConnection.getContentEncoding()); &#125; stream = urlConnection.getInputStream(); &#125; return stream; &#125;&#125; loadData() 方法内部又去调用了 loadDataWithRedirects() 方法，loadDataWithRedirects() 方法内部使用 UrlConnection 获取了从服务器返回的 InputStream。至此，Glide 根据 URL 的字符串向服务器发起请求并成功收到响应，万里长征才算是刚刚完成一半。 回到 loadData() 方法，收到服务器返回的 InputStream 之后，用它来构建一个封装类 ImageVideoWrapper 并返回。继续向上返回到 decodeSource() 方法，接下来调用 decodeFromSourceData() 进行解码 1234567891011121314151617private Resource&lt;T&gt; decodeFromSourceData(A data) throws IOException &#123; final Resource&lt;T&gt; decoded; ///判断磁盘缓存策略中是否缓存 Source,缓存 ImageVideoWrapper 并 decode if (diskCacheStrategy.cacheSource()) &#123; decoded = cacheAndDecodeSourceData(data); &#125; else &#123; ///loadProvider就是刚才在onSizeReady()方法中得到的FixedLoadProvider， // 而getSourceDecoder()得到的则是一个GifBitmapWrapperResourceDecoder对象, // 得到Resource&lt;GifBitmapWrapper&gt; long startTime = LogTime.getLogTime(); decoded = loadProvider.getSourceDecoder().decode(data, width, height); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Decoded from source&quot;, startTime); &#125; &#125; return decoded;&#125; 我们来看不进行缓存的分支，loadProvider.getSourceDecoder() 获取一个 SourceDecoder，我们分析过，会得到一个 GifBitmapWrapperResourceDecoder 对象，解码工作交给它来执行，我们看看它的 decode() 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public Resource&lt;GifBitmapWrapper&gt; decode(ImageVideoWrapper source, int width, int height) throws IOException &#123; ByteArrayPool pool = ByteArrayPool.get(); byte[] tempBytes = pool.getBytes(); GifBitmapWrapper wrapper = null; try &#123; wrapper = decode(source, width, height, tempBytes); &#125; finally &#123; pool.releaseBytes(tempBytes); &#125; return wrapper != null ? new GifBitmapWrapperResource(wrapper) : null;&#125;private GifBitmapWrapper decode(ImageVideoWrapper source, int width, int height, byte[] bytes) throws IOException &#123; final GifBitmapWrapper result; if (source.getStream() != null) &#123; ///准备从服务器返回的流当中读取数据 result = decodeStream(source, width, height, bytes); &#125; else &#123; result = decodeBitmapWrapper(source, width, height); &#125; return result;&#125;///decodeStream()方法中会先从流中读取2个字节的数据，来判断这张图是GIF图还是普通的静图，// 如果是GIF图就调用decodeGifWrapper()方法来进行解码，如果是普通的静图就用调用decodeBitmapWrapper()方法来进行解码private GifBitmapWrapper decodeStream(ImageVideoWrapper source, int width, int height, byte[] bytes) throws IOException &#123; InputStream bis = streamFactory.build(source.getStream(), bytes); bis.mark(MARK_LIMIT_BYTES); ImageHeaderParser.ImageType type = parser.parse(bis); bis.reset(); GifBitmapWrapper result = null; if (type == ImageHeaderParser.ImageType.GIF) &#123; result = decodeGifWrapper(bis, width, height); &#125; // Decoding the gif may fail even if the type matches. if (result == null) &#123; // We can only reset the buffered InputStream, so to start from the beginning of the stream, we need to // pass in a new source containing the buffered stream rather than the original stream. ImageVideoWrapper forBitmapDecoder = new ImageVideoWrapper(bis, source.getFileDescriptor()); result = decodeBitmapWrapper(forBitmapDecoder, width, height); &#125; return result;&#125;private GifBitmapWrapper decodeBitmapWrapper(ImageVideoWrapper toDecode, int width, int height) throws IOException &#123; GifBitmapWrapper result = null; ///这个bitmapDecoder是一个ImageVideoBitmapDecoder对象.将InputStream或者ParcelFileDescriptor转换成bitmap Resource&lt;Bitmap&gt; bitmapResource = bitmapDecoder.decode(toDecode, width, height); if (bitmapResource != null) &#123; result = new GifBitmapWrapper(bitmapResource, null); &#125; return result;&#125;private GifBitmapWrapper decodeGifWrapper(InputStream bis, int width, int height) throws IOException &#123; GifBitmapWrapper result = null; ///GifResourceDecoder Resource&lt;GifDrawable&gt; gifResource = gifDecoder.decode(bis, width, height); if (gifResource != null) &#123; GifDrawable drawable = gifResource.get(); // We can more efficiently hold Bitmaps in memory, so for static GIFs, try to return Bitmaps // instead. Returning a Bitmap incurs the cost of allocating the GifDrawable as well as the normal // Bitmap allocation, but since we can encode the Bitmap out as a JPEG, future decodes will be // efficient. if (drawable.getFrameCount() &gt; 1) &#123; result = new GifBitmapWrapper(null /*bitmapResource*/, gifResource); &#125; else &#123; Resource&lt;Bitmap&gt; bitmapResource = new BitmapResource(drawable.getFirstFrame(), bitmapPool); result = new GifBitmapWrapper(bitmapResource, null /*gifResource*/); &#125; &#125; return result;&#125; decode() 方法内部调用了重载的 decode() 方法，其内部调用了 decodeStream() 将 InputStream 解码成图片。 decodeStream() 方法中会从流中读取2个字节的数据来判断这张图是 Gif 还是普通的静图，如果是 Gif 图则调用 decodeGifWrapper() 方法来进行解码，如果是普通的静图就用调用 decodeBitmapWrapper() 方法来进行解码。这里选取比较常见的静图解码来分析。 decodeBitmapWrapper() 方法内部调用 bitmapDecoder 对象的 decode() 方法，然后封装成一个GifBitmapWrapper。bitmapDecoder 实际上是一个 ImageVideoBitmapDecoder 对象，来看一下它的 decode() 方法。 12345678910111213141516171819202122232425262728public class ImageVideoBitmapDecoder implements ResourceDecoder&lt;ImageVideoWrapper, Bitmap&gt; &#123; @SuppressWarnings(&quot;resource&quot;) // @see ResourceDecoder.decode @Override public Resource&lt;Bitmap&gt; decode(ImageVideoWrapper source, int width, int height) throws IOException &#123; Resource&lt;Bitmap&gt; result = null; InputStream is = source.getStream(); if (is != null) &#123; try &#123; ///streamDecode是一个StreamBitmapDecoder对象 result = streamDecoder.decode(is, width, height); &#125; catch (IOException e) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, &quot;Failed to load image from stream, trying FileDescriptor&quot;, e); &#125; &#125; &#125; if (result == null) &#123; ParcelFileDescriptor fileDescriptor = source.getFileDescriptor(); if (fileDescriptor != null) &#123; result = fileDescriptorDecoder.decode(fileDescriptor, width, height); &#125; &#125; return result; &#125;&#125; ImageVideoBitmapDecoder 的 decode() 方法内部又将解码工作交给了 StreamBitmapDecoder 对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889===StreamBitmapDecoder.java===public class StreamBitmapDecoder implements ResourceDecoder&lt;InputStream, Bitmap&gt; &#123; @Override public Resource&lt;Bitmap&gt; decode(InputStream source, int width, int height) &#123; Bitmap bitmap = downsampler.decode(source, bitmapPool, width, height, decodeFormat); return BitmapResource.obtain(bitmap, bitmapPool); &#125;&#125;===Downsampler.java===public Bitmap decode(InputStream is, BitmapPool pool, int outWidth, int outHeight, DecodeFormat decodeFormat) &#123; final ByteArrayPool byteArrayPool = ByteArrayPool.get(); final byte[] bytesForOptions = byteArrayPool.getBytes(); final byte[] bytesForStream = byteArrayPool.getBytes(); final BitmapFactory.Options options = getDefaultOptions(); // Use to fix the mark limit to avoid allocating buffers that fit entire images. RecyclableBufferedInputStream bufferedStream = new RecyclableBufferedInputStream( is, bytesForStream); // Use to retrieve exceptions thrown while reading. // TODO(#126): when the framework no longer returns partially decoded Bitmaps or provides a way to determine // if a Bitmap is partially decoded, consider removing. ExceptionCatchingInputStream exceptionStream = ExceptionCatchingInputStream.obtain(bufferedStream); // Use to read data. // Ensures that we can always reset after reading an image header so that we can still attempt to decode the // full image even when the header decode fails and/or overflows our read buffer. See #283. MarkEnforcingInputStream invalidatingStream = new MarkEnforcingInputStream(exceptionStream); try &#123; exceptionStream.mark(MARK_POSITION); int orientation = 0; try &#123; orientation = new ImageHeaderParser(exceptionStream).getOrientation(); &#125; catch (IOException e) &#123; if (Log.isLoggable(TAG, Log.WARN)) &#123; Log.w(TAG, &quot;Cannot determine the image orientation from header&quot;, e); &#125; &#125; finally &#123; try &#123; exceptionStream.reset(); &#125; catch (IOException e) &#123; if (Log.isLoggable(TAG, Log.WARN)) &#123; Log.w(TAG, &quot;Cannot reset the input stream&quot;, e); &#125; &#125; &#125; options.inTempStorage = bytesForOptions; ///编码过程中通过设置采样率缩放图片，降低内存占用，提高加载性能。 final int[] inDimens = getDimensions(invalidatingStream, bufferedStream, options); final int inWidth = inDimens[0]; final int inHeight = inDimens[1]; final int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation); final int sampleSize = getRoundedSampleSize(degreesToRotate, inWidth, inHeight, outWidth, outHeight); final Bitmap downsampled = downsampleWithSize(invalidatingStream, bufferedStream, options, pool, inWidth, inHeight, sampleSize, decodeFormat); // BitmapFactory swallows exceptions during decodes and in some cases when inBitmap is non null, may catch // and log a stack trace but still return a non null bitmap. To avoid displaying partially decoded bitmaps, // we catch exceptions reading from the stream in our ExceptionCatchingInputStream and throw them here. final Exception streamException = exceptionStream.getException(); if (streamException != null) &#123; throw new RuntimeException(streamException); &#125; Bitmap rotated = null; if (downsampled != null) &#123; rotated = TransformationUtils.rotateImageExif(downsampled, pool, orientation); if (!downsampled.equals(rotated) &amp;&amp; !pool.put(downsampled)) &#123; downsampled.recycle(); &#125; &#125; return rotated; &#125; finally &#123; byteArrayPool.releaseBytes(bytesForOptions); byteArrayPool.releaseBytes(bytesForStream); exceptionStream.release(); releaseOptions(options); &#125; &#125; 经过层层跋涉，可以看到最终的解码工作就在 Downsampler 的 decode() 方法这里了。里面包含很多的逻辑，包括对图片的压缩，甚至还有旋转、圆角等逻辑处理。总之，decode() 最终返回了一个 Bitmap 对象。然后向上层层返回，在 StreamBitmapDecoder 的 decode() 方法中 Bitmap 被封装成 Resource\ 对象。在 GifBitmapWrapperResourceDecoder 的 decodeBitmapWrapper() 方法中Resource\ 进而被封装成 GifBitmapWrapper 对象。最后在 GifBitmapWrapperResourceDecoder 的 decode() 方法中封装成 Resource\ 对象。 有点混乱，这里用图表整理一下 方法 返回值 封装内容 GifBitmapWrapperResourceDecoder.decode() Resource\ GifBitmapWrapper GifBitmapWrapperResourceDecoder.decodeBitmapWrapper() GifBitmapWrapper Resource\和Resource\ StreamBitmapDecoder.decode() Resource\ Bitmap Downsampler.decode() Bitmap 可以看到，不管加载的是静图还是Gif动图，都能通过返回 Resource\ 对象来表示 最后经过千辛万苦，返回到了 DecodeJob 的 decodeFromSource() 方法中，得到 Resource\ 对象，解码工作完成。 123456public Resource&lt;Z&gt; decodeFromSource() throws Exception &#123; ///返回Resource&lt;GifBitmapWrapper&gt; Resource&lt;T&gt; decoded = decodeSource(); ///返回了Resource&lt;GlideDrawable&gt;,统一了静态图和动图类型 return transformEncodeAndTranscode(decoded); &#125; 接下来就是转化和转码的工作了，来看下 transformEncodeAndTranscode() 方法 123456789101112131415161718private Resource&lt;Z&gt; transformEncodeAndTranscode(Resource&lt;T&gt; decoded) &#123; long startTime = LogTime.getLogTime(); Resource&lt;T&gt; transformed = transform(decoded); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Transformed resource from source&quot;, startTime); &#125; ///将transform后的resource写入缓存 writeTransformedToCache(transformed); startTime = LogTime.getLogTime(); ///返回了Resource&lt;GlideDrawable&gt; Resource&lt;Z&gt; result = transcode(transformed); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Transcoded transformed from source&quot;, startTime); &#125; return result; &#125; 同样写入缓存的部分略过，transformEncodeAndTranscode() 的主要工作包括两部分，调用 transform() 方法进行图片的变换，然后调用 transcode() 方法进行转码。先来看下 transform() 方法 12345678910111213private Resource&lt;T&gt; transform(Resource&lt;T&gt; decoded) &#123; if (decoded == null) &#123; return null; &#125; ///GenericRequestBuilder.into中根据imageview的scaletype保存了transformation, // 比如是drawable的centercrop那么transformation就是GifBitmapWrapperTransformation(内部封装类型为CenterCrop的BitmapTransformation对象) Resource&lt;T&gt; transformed = transformation.transform(decoded, width, height); if (!decoded.equals(transformed)) &#123; decoded.recycle(); &#125; return transformed;&#125; 方法内部调用了 transformation 对象的 transform 来执行图片变换。还记得 GenericRequestBuilder 的 into() 方法么？当时就判断了 ImageView 的 ScaleType,将对应的 Transformation 实例保存在 transformation，这里的 transformation 对象实际上就是由 GenericRequestBuilder 传过来的。 假设当前 ImageView 的 ScaleType 是 CenterCrop，那么得到 transformation 对象就是 GifBitmapWrapperTransformation，其内部封装了用于 Bitmap 变换 的 Transformation 实例 CenterCrop 对象，还有用于 GifDrawable 变换的 Transformation 实例 GifDrawableTransformation 对象。 那么我们看看 GifBitmapWrapperTransformation 的 transform() 方法 123456789101112131415161718192021222324252627282930313233public class GifBitmapWrapperTransformation implements Transformation&lt;GifBitmapWrapper&gt; &#123; public GifBitmapWrapperTransformation(BitmapPool bitmapPool, Transformation&lt;Bitmap&gt; bitmapTransformation) &#123; this(bitmapTransformation, new GifDrawableTransformation(bitmapTransformation, bitmapPool)); &#125; GifBitmapWrapperTransformation(Transformation&lt;Bitmap&gt; bitmapTransformation, Transformation&lt;GifDrawable&gt; gifDataTransformation) &#123; this.bitmapTransformation = bitmapTransformation; this.gifDataTransformation = gifDataTransformation; &#125; @Override public Resource&lt;GifBitmapWrapper&gt; transform(Resource&lt;GifBitmapWrapper&gt; resource, int outWidth, int outHeight) &#123; Resource&lt;Bitmap&gt; bitmapResource = resource.get().getBitmapResource(); Resource&lt;GifDrawable&gt; gifResource = resource.get().getGifResource(); if (bitmapResource != null &amp;&amp; bitmapTransformation != null) &#123; ///FitCenter 或 CenterCrop Resource&lt;Bitmap&gt; transformed = bitmapTransformation.transform(bitmapResource, outWidth, outHeight); if (!bitmapResource.equals(transformed)) &#123; GifBitmapWrapper gifBitmap = new GifBitmapWrapper(transformed, resource.get().getGifResource()); return new GifBitmapWrapperResource(gifBitmap); &#125; &#125; else if (gifResource != null &amp;&amp; gifDataTransformation != null) &#123; Resource&lt;GifDrawable&gt; transformed = gifDataTransformation.transform(gifResource, outWidth, outHeight); if (!gifResource.equals(transformed)) &#123; GifBitmapWrapper gifBitmap = new GifBitmapWrapper(resource.get().getBitmapResource(), transformed); return new GifBitmapWrapperResource(gifBitmap); &#125; &#125; return resource; &#125;&#125; GifBitmapWrapperTransformation 是一个 Transformation\，它变换的对象是 GifBitmapWrapper，自然也就需要执行 Bitmap 或者 GifDrawable 的变换。首先判断 GifBitmapWrapper 中封装的是静图 Bitmap 还是 动图 Gif，然后再交给对应的 Transformation 实例做变换。如果 ImageView 的 ScaleType 是 CenterCrop，那么此处的 bitmapTransformation 就是 CenterCrop 对象，那么我们来看看 CenterCrop 的 transform() 方法 12345678910111213141516public class CenterCrop extends BitmapTransformation &#123; // Bitmap doesn&apos;t implement equals, so == and .equals are equivalent here. @SuppressWarnings(&quot;PMD.CompareObjectsWithEquals&quot;) @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; ///从 BitmapPool 中获取可复用的 Bitmap final Bitmap toReuse = pool.get(outWidth, outHeight, toTransform.getConfig() != null ? toTransform.getConfig() : Bitmap.Config.ARGB_8888); Bitmap transformed = TransformationUtils.centerCrop(toReuse, toTransform, outWidth, outHeight); if (toReuse != null &amp;&amp; toReuse != transformed &amp;&amp; !pool.put(toReuse)) &#123; toReuse.recycle(); &#125; return transformed; &#125;&#125; transform() 方法最终调用了 TransformationUtils 的静态方法 centerCrop() 去处理 1234567891011121314151617181920212223242526272829303132333435public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) &#123; if (toCrop == null) &#123; return null; &#125; else if (toCrop.getWidth() == width &amp;&amp; toCrop.getHeight() == height) &#123; return toCrop; &#125; // From ImageView/Bitmap.createScaledBitmap. final float scale; float dx = 0, dy = 0; Matrix m = new Matrix(); if (toCrop.getWidth() * height &gt; width * toCrop.getHeight()) &#123; scale = (float) height / (float) toCrop.getHeight(); dx = (width - toCrop.getWidth() * scale) * 0.5f; &#125; else &#123; scale = (float) width / (float) toCrop.getWidth(); dy = (height - toCrop.getHeight() * scale) * 0.5f; &#125; m.setScale(scale, scale); m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f)); final Bitmap result; if (recycled != null) &#123; result = recycled; &#125; else &#123; result = Bitmap.createBitmap(width, height, getSafeConfig(toCrop)); &#125; // We don&apos;t add or remove alpha, so keep the alpha setting of the Bitmap we were given. TransformationUtils.setAlpha(toCrop, result); Canvas canvas = new Canvas(result); Paint paint = new Paint(PAINT_FLAGS); canvas.drawBitmap(toCrop, m, paint); return result; &#125; centerCrop() 方法就是根据给定的宽和高来缩放 toCrop Bitmap，使得 bitmap 的其中一边与给定宽高相等，而另一边较长，然后进行截取。那么经过 centerCrop() 方法处理，我们就得到了一个经过变换的 Bitmap。一直向上返回，一直回到 transformEncodeAndTranscode() 方法 123456789101112131415161718private Resource&lt;Z&gt; transformEncodeAndTranscode(Resource&lt;T&gt; decoded) &#123; long startTime = LogTime.getLogTime(); Resource&lt;T&gt; transformed = transform(decoded); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Transformed resource from source&quot;, startTime); &#125; ///将transform后的resource写入缓存 writeTransformedToCache(transformed); startTime = LogTime.getLogTime(); ///返回了Resource&lt;GlideDrawable&gt; Resource&lt;Z&gt; result = transcode(transformed); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Transcoded transformed from source&quot;, startTime); &#125; return result; &#125; transformEncodeAndTranscode() 方法的工作已经完成一半，目前我们得到的还是 Resource\ 对象，只不过 其中封装的 Resource\ 已经根据 ScaleType 进行了变换。 然后转码的功过就是在  transcode(）方法内部了，要注意的是它将返回的是 Resource\ 对象 1234567private Resource&lt;Z&gt; transcode(Resource&lt;T&gt; transformed) &#123; if (transformed == null) &#123; return null; &#125; ///GifBitmapWrapperDrawableTranscoder return transcoder.transcode(transformed); &#125; 方法内部又调用了 transcoder 的 transcode() 方法。这里的 transcoder 是什么呢？让我们追本溯源，发现答案就在 DrawableRequestBuilder 的构造函数。 当时在 DrawableRequestBuilder 的构造函数中创建了一个 FixedLoadProvider 对象，创建 FixedLoadProvider 对象的时候，在它的构造函数里传了一个 GifBitmapWrapperDrawableTranscoder 对象，后来这个 GifBitmapWrapperDrawableTranscoder 不远千里，途经 GenericRequest、Engine 来到 DecodeJob。所以 transcoder 就是 GifBitmapWrapperDrawableTranscoder 对象。 那么我们看看它的 transcode 方法 1234567891011121314151617181920212223242526///GifBitmapWrapperDrawableTranscoder的核心作用就是用来转码的。// 因为GifBitmapWrapper是无法直接显示到ImageView上面的，只有Bitmap或者Drawable才能显示到ImageView上。// 因此，这里的transcode()方法先从Resource&lt;GifBitmapWrapper&gt;中取出GifBitmapWrapper对象，然后再从GifBitmapWrapper中取出Resource&lt;Bitmap&gt;对象。public class GifBitmapWrapperDrawableTranscoder implements ResourceTranscoder&lt;GifBitmapWrapper, GlideDrawable&gt; &#123; ///转码之后,因为不管是静图的Resource&lt;GlideBitmapDrawable&gt;对象， // 还是动图的Resource&lt;GifDrawable&gt;对象，它们都是属于父类Resource&lt;GlideDrawable&gt;对象的 @SuppressWarnings(&quot;unchecked&quot;) @Override public Resource&lt;GlideDrawable&gt; transcode(Resource&lt;GifBitmapWrapper&gt; toTranscode) &#123; GifBitmapWrapper gifBitmap = toTranscode.get(); Resource&lt;Bitmap&gt; bitmapResource = gifBitmap.getBitmapResource(); final Resource&lt;? extends GlideDrawable&gt; result; if (bitmapResource != null) &#123; ///说明加载的是bitmap,需要再做一次转码，将Bitmap转换成Drawable对象.因为要保证静图和动图的类型一致性，不然逻辑上是不好处理的。 ///使用GlideBitmapDrawableTranscoder将bitmap转化成Resource&lt;GlideBitmapDrawable&gt; result = bitmapDrawableResourceTranscoder.transcode(bitmapResource); &#125; else &#123; ///说明此时加载的是GIF图.因为Glide用于加载GIF图片是使用的GifDrawable这个类，它本身就是一个Drawable对象了 result = gifBitmap.getGifResource(); &#125; // This is unchecked but always safe, anything that extends a Drawable can be safely cast to a Drawable. return (Resource&lt;GlideDrawable&gt;) result; &#125;&#125; 转码的目的是为了统一静图和动图 Gif 的类型，是它们都属于 Drawable 类型，以便统一处理逻辑。Glide 中 Gif 动图用 GifDrawable 表示，本身就是 Drawable 的子类，所以不需要转码。而静图 Bitmap 则需要转码为 Drawable。 程序先从 Resource\ 取出 GifBitmapWrapper，然后在 GifBitmapWrapper 中取出 Resource\。对于 Bitmap 的转码，在 transcode() 方法中交给了 bitmapDrawableResourceTranscoder 处理，bitmapDrawableResourceTranscoder 是一个 GlideBitmapDrawableTranscoder 对象，下面看看它的 transcode() 方法 12345678public class GlideBitmapDrawableTranscoder implements ResourceTranscoder&lt;Bitmap, GlideBitmapDrawable&gt; &#123; @Override public Resource&lt;GlideBitmapDrawable&gt; transcode(Resource&lt;Bitmap&gt; toTranscode) &#123; GlideBitmapDrawable drawable = new GlideBitmapDrawable(resources, toTranscode.get()); return new GlideBitmapDrawableResource(drawable, bitmapPool); &#125;&#125; 这里 创建了一个 GlideBitmapDrawable，然后把 Bitmap 封装到里面，然后对 GlideBitmapDrawable 再一次封装，返回一个 Resource\ 对象。 现在不管是静图 Resource\ 还是动图 Resource\ ，它们都属于父类Resource\对象。 那么现在转码的工作也已经完成了，只剩下将图片显示出来的工作了。从 DecodeJob 的 transformEncodeAndTranscode() 方法开始向上返回，一直返回到 EngineRunnable 的 run() 方法，我们重新看一下代码 1234567891011121314151617181920212223242526272829303132@Override public void run() &#123; if (isCancelled) &#123; return; &#125; Exception exception = null; Resource&lt;?&gt; resource = null; try &#123; ///得到了Resource&lt;GlideDrawable&gt;对象 resource = decode(); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, &quot;Exception decoding&quot;, e); &#125; exception = e; &#125; if (isCancelled) &#123; if (resource != null) &#123; resource.recycle(); &#125; return; &#125; if (resource == null) &#123; /// 第一次走decode()尝试从磁盘获取,失败后会走这里。重新进入decode onLoadFailed(exception); &#125; else &#123; onLoadComplete(resource); &#125; &#125; 上次我们从 decode() 方法开始追溯，经过向服务发送请求，接收 InputStream，将 InputStream 解码成 Bitmap 或者 GifDrawable，然后经过 ScaleType 变换，转码 的一系列复杂逻辑，现在终于从 decode() 方法出来了，真是恍如隔世，现在我们拥有了 Resource\对象，准备将图片显示出来。 显然接下来就是调用 onLoadComplete() 方法了 1234private void onLoadComplete(Resource resource) &#123; ///manager就是EngineJob对象 manager.onResourceReady(resource); &#125; 只有简单的一行代码，这个 manager 实际上是 EngineJob 对象，上次提到它是负责统一管理加载请求的 onResourceReady() 回调的，那么我们来看一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class EngineJob implements EngineRunnable.EngineRunnableManager &#123; private static final Handler MAIN_THREAD_HANDLER = new Handler(Looper.getMainLooper(), new MainThreadCallback()); public void addCallback(ResourceCallback cb) &#123; Util.assertMainThread(); if (hasResource) &#123; cb.onResourceReady(engineResource); &#125; else if (hasException) &#123; cb.onException(exception); &#125; else &#123; cbs.add(cb); &#125; &#125; @Override public void onResourceReady(final Resource&lt;?&gt; resource) &#123; this.resource = resource; ///使用Handler发出了一条MSG_COMPLETE消息，那么在MainThreadCallback的handleMessage()方法中就会收到这条消息。 // 从这里开始，所有的逻辑又回到主线程当中进行了 MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget(); &#125; private void handleResultOnMainThread() &#123; if (isCancelled) &#123; resource.recycle(); return; &#125; else if (cbs.isEmpty()) &#123; throw new IllegalStateException(&quot;Received a resource without any callbacks to notify&quot;); &#125; ///封装成一个EngineResource engineResource = engineResourceFactory.build(resource, isCacheable); hasResource = true; // Hold on to resource for duration of request so we don&apos;t recycle it in the middle of notifying if it // synchronously released by one of the callbacks. engineResource.acquire(); ///key是一个EngineKey。如果resource.isCacheable()为true,resource将添加到activeResources中,并在移除时加入到memorycache listener.onEngineJobComplete(key, engineResource); ///这里的ResourceCallback就是GenericRequest,由GenericRequest调用EngineJob的load方法时传入 for (ResourceCallback cb : cbs) &#123; if (!isInIgnoredCallbacks(cb)) &#123; engineResource.acquire(); ///回调GenericRequest cb.onResourceReady(engineResource); &#125; &#125; // Our request is complete, so we can release the resource. engineResource.release(); &#125; private static class MainThreadCallback implements Handler.Callback &#123; @Override public boolean handleMessage(Message message) &#123; if (MSG_COMPLETE == message.what || MSG_EXCEPTION == message.what) &#123; EngineJob job = (EngineJob) message.obj; if (MSG_COMPLETE == message.what) &#123; job.handleResultOnMainThread(); &#125; else &#123; job.handleExceptionOnMainThread(); &#125; return true; &#125; return false; &#125; &#125;&#125; 这里贴上了相关的代码。在 onResourceReady() 方法中 使用 MAIN_THREAD_HANDLER 发送了一条 MSG_COMPLETE 消息。MAIN_THREAD_HANDLER 是用 Looper.getMainLooper() 构建的一个 Handler 对象，那么 MainThreadCallback 的 handleMessage() 将会在主线程中运行。这一意味着即将要更新 UI 了。 handleResultOnMainThread() 方法中通过循环，遍历了所有 ResourceCallback 的 onResourceReady() 方法。这些 ResourceCallback 都是谁呢？看看谁调用过 EngineJob 的 addCallback() 方法就知道了。其实我们都已经见过了 12345678910111213141516171819202122232425262728293031public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher, DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder, Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) &#123; ...... EngineJob current = jobs.get(key); if (current != null) &#123; current.addCallback(cb); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key); &#125; return new LoadStatus(cb, current); &#125; ///EngineJob的主要作用就是用来开启线程的，为后面的异步加载图片做准备 EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable); DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation, transcoder, diskCacheProvider, diskCacheStrategy, priority); EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority); jobs.put(key, engineJob); ///将GenericRequest的回调接口交给enginejob engineJob.addCallback(cb); ///实际上就是让EngineRunnable的run()方法在子线程当中执行了 engineJob.start(runnable); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Started new load&quot;, startTime, key); &#125; return new LoadStatus(cb, engineJob); &#125; 在 Engine 的 load() 方法中，在运行 EngingRunnale 之前，使用 cb 参数调用了 EngineJob 的 addCallback() 方法，以便图片加载完毕之后收到回调。而 cb 就是 GenericRequest 调用 Engine 的 load() 方法时传过来的它自己本身，因为 GenericRequest 本身就实现了 ResourceCallback 接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@SuppressWarnings(&quot;unchecked&quot;)@Overridepublic void onResourceReady(Resource&lt;?&gt; resource) &#123; if (resource == null) &#123; onException(new Exception(&quot;Expected to receive a Resource&lt;R&gt; with an object of &quot; + transcodeClass + &quot; inside, but instead got null.&quot;)); return; &#125; ///resource是一个EngineResource,获取到GlideBitmapDrawable 或者是 GifDrawable Object received = resource.get(); if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) &#123; releaseResource(resource); onException(new Exception(&quot;Expected to receive an object of &quot; + transcodeClass + &quot; but instead got &quot; + (received != null ? received.getClass() : &quot;&quot;) + &quot;&#123;&quot; + received + &quot;&#125;&quot; + &quot; inside Resource&#123;&quot; + resource + &quot;&#125;.&quot; + (received != null ? &quot;&quot; : &quot; &quot; + &quot;To indicate failure return a null Resource object, &quot; + &quot;rather than a Resource object containing null data.&quot;) )); return; &#125; if (!canSetResource()) &#123; releaseResource(resource); // We can&apos;t set the status to complete before asking canSetResource(). status = Status.COMPLETE; return; &#125; onResourceReady(resource, (R) received);&#125;private void onResourceReady(Resource&lt;?&gt; resource, R result) &#123; // We must call isFirstReadyResource before setting status. boolean isFirstResource = isFirstReadyResource(); status = Status.COMPLETE; this.resource = resource; if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache, isFirstResource)) &#123; GlideAnimation&lt;R&gt; animation = animationFactory.build(loadedFromMemoryCache, isFirstResource); ///target就是调用into时构建的GlideDrawableImageViewTarget target.onResourceReady(result, animation); &#125; notifyLoadSuccess(); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(&quot;Resource ready in &quot; + LogTime.getElapsedMillis(startTime) + &quot; size: &quot; + (resource.getSize() * TO_MEGABYTE) + &quot; fromCache: &quot; + loadedFromMemoryCache); &#125;&#125; 这里有 GenericRequest 中有两个 onResourceReady() 方法，第一个就是 ResourceCallback 接口的方法。该方法中首先调用了 EngineResource 的 get() 方法获取它所封装的 GlideBitmapDrawable 或者是 GifDrawable，然后调用了另一个 onResourceReady() 方法。 在另一个方法中调用了 target 的 onResourceReady() 方法，target 实际上就是我们调用第三步 into() 方法时传的 GlideDrawableImageViewTarget 对象。我们看看它的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class GlideDrawableImageViewTarget extends ImageViewTarget&lt;GlideDrawable&gt; &#123; private static final float SQUARE_RATIO_MARGIN = 0.05f; private int maxLoopCount; private GlideDrawable resource; public GlideDrawableImageViewTarget(ImageView view) &#123; this(view, GlideDrawable.LOOP_FOREVER); &#125; public GlideDrawableImageViewTarget(ImageView view, int maxLoopCount) &#123; super(view); this.maxLoopCount = maxLoopCount; &#125; @Override public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; animation) &#123; if (!resource.isAnimated()) &#123; float viewRatio = view.getWidth() / (float) view.getHeight(); float drawableRatio = resource.getIntrinsicWidth() / (float) resource.getIntrinsicHeight(); if (Math.abs(viewRatio - 1f) &lt;= SQUARE_RATIO_MARGIN &amp;&amp; Math.abs(drawableRatio - 1f) &lt;= SQUARE_RATIO_MARGIN) &#123; resource = new SquaringDrawable(resource, view.getWidth()); &#125; &#125; super.onResourceReady(resource, animation); this.resource = resource; resource.setLoopCount(maxLoopCount); resource.start(); &#125; /** * Sets the drawable on the view using * &#123;@link android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)&#125;. * * @param resource The &#123;@link android.graphics.drawable.Drawable&#125; to display in the view. */ @Override protected void setResource(GlideDrawable resource) &#123; view.setImageDrawable(resource); &#125; @Override public void onStart() &#123; if (resource != null) &#123; resource.start(); &#125; &#125; @Override public void onStop() &#123; if (resource != null) &#123; resource.stop(); &#125; &#125;&#125; GlideDrawableImageViewTarget 的 onResourceReady() 方法中调用了父类的 onResourceReady() 方法 1234567public void onResourceReady(Z resource, GlideAnimation&lt;? super Z&gt; glideAnimation) &#123; if (glideAnimation == null || !glideAnimation.animate(resource, this)) &#123; setResource(resource); &#125;&#125;protected abstract void setResource(Z resource); 父类的 onResourceReady() 方法调用了子类的 setResource() 实现，回头看一下，GlideDrawableImageViewTarget 的 setResource() 实现 调用了 view.setImageDrawable() 方法，这个 view 就是所封装的 ImageView 对象。图片也就成功显示出来了。 那么，Glide 加载基本流程的源码分析就到此结束。我已经尽力将它描述清楚，希望各位有所收获。 感谢坚持看到这里的你们。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Glide</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听听，一款优雅的开源音乐播放器]]></title>
    <url>%2F2017%2F04%2F15%2F%E5%90%AC%E5%90%AC%EF%BC%8C%E4%B8%80%E6%AC%BE%E4%BC%98%E9%9B%85%E7%9A%84%E5%BC%80%E6%BA%90%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%2F</url>
    <content type="text"><![CDATA[ListenerMusicPlayer一款优雅的遵循 Material Design 的开源音乐播放器，UI参考 腾讯轻听 音乐播放器,使用 Lastfm Api 与 酷狗歌词Api。项目架构采用 mvp-clean，基于 Retrofit2 + Dagger2 + RxJava + RxBus + Glide。 github地址：ListenerMusicPlayer 效果图 部分截图 gif演示 模块分析 我的歌曲：展示本地所有的音乐文件，由歌曲、歌手、专辑三个标签页分类展示，数据取自系统媒体库。为了防止媒体库数据与本地不同步，应用启动时会主动刷新媒体库。 正在播放：该模块体现为固定在每个页面下方的播放控制区，展开后可查看全部操作，包括标记喜欢、打开播放列表及查看歌词。歌词API由酷狗提供。 文件夹：展示本地所有包含音乐文件个文件夹 我的歌单：展示用户创建的歌单 我喜欢：展示用户标记为喜欢的歌曲 最近播放：展示用户最近播放的歌曲 最近添加：展示最近添加的歌曲 播放排行：综合歌曲过去每周的播放历史和当前周播放次数得出歌曲排行 本地搜索：根据关键词搜索相关的歌曲、专辑和歌手 设置：该模块包括切换日夜间模式和更换出题 主要技术点梳理那么，从本项目中你能学到哪些知识呢？ 高仿轻听UI，最为酷炫的正在播放模块也得到了高度还原 使用 app-theme-engine 轻松实现日夜间切换和主题更换 使用独立进程负责播放，进程间AIDL通信 mvp-clean架构的使用 透明状态栏使用与版本适配 使用RxBus进行组件间通信 自定义View如LyricView、PlayPauseView的实现 通过自定义Behavior实现自定义FloatingActionButton进出动画 使用ScrimUtil实现更加平滑的单色渐变效果 使用RxJava对数据进行过滤和转化 Thanks 参考项目 : Timber 、 轻听 图片来源 : Material design icon 、 腾讯轻听App Api : LastFM 、 酷狗音乐 开源库 : RxJava 、 Retrofit 、 Glide 、 AndroidSlidingUpPanel等等 Statement感谢轻听提供参考，轻听是一款十分良心的音乐播放器，本人使用了其中的部分素材，如构成侵权请及时通知我修改或删除。部分数据来自于干LastFM和酷狗歌词Api，一切数据解释权都归LastFM和酷狗所有。 End 注意：此开源项目仅做学习交流使用，如果你觉得不错，对你有帮助，欢迎点个fork，star，follow，也可以帮忙分享给你更多的朋友，这是给我们最大的动力与支持。 Contact Me Github: github.com/hefuyicoder Email: hefuyicoder@gmail.com]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>开源项目</tag>
        <tag>music player</tag>
      </tags>
  </entry>
</search>