<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Glide,源码分析," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="对于 Glide 相信大家都不陌生，它是 Google 员工 bumptech 开源的一款图片加载框架，因为其简单易用的 API ，强大的功能，优秀的内存管理被 Google 官方所推荐并且被广泛运用在 Google 的开源项目中。目前 Glide 、Picasso 和 Fresco 都是比较主流图片加载框架。
它们的使用场景基本都是重合的，而本人对 Glide 更为熟悉，所以选取 Glide 来">
<meta property="og:type" content="article">
<meta property="og:title" content="Glide源码解析（一）：加载流程">
<meta property="og:url" content="http://hefuyicoder.com/2017/04/27/Glide源码解析（一）：加载流程/index.html">
<meta property="og:site_name" content="乌有先生的个人博客">
<meta property="og:description" content="对于 Glide 相信大家都不陌生，它是 Google 员工 bumptech 开源的一款图片加载框架，因为其简单易用的 API ，强大的功能，优秀的内存管理被 Google 官方所推荐并且被广泛运用在 Google 的开源项目中。目前 Glide 、Picasso 和 Fresco 都是比较主流图片加载框架。
它们的使用场景基本都是重合的，而本人对 Glide 更为熟悉，所以选取 Glide 来">
<meta property="og:image" content="http://o8swcawjo.bkt.clouddn.com/glideprocress.png">
<meta property="og:image" content="http://o8swcawjo.bkt.clouddn.com/DrawableTypeRequest.png">
<meta property="og:image" content="http://o8swcawjo.bkt.clouddn.com/GenericRequestBuilder.png">
<meta property="og:image" content="http://o8swcawjo.bkt.clouddn.com/DataLoadProvider.png">
<meta property="og:image" content="http://o8swcawjo.bkt.clouddn.com/FixLoadProvider.png">
<meta property="og:updated_time" content="2017-05-08T03:47:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Glide源码解析（一）：加载流程">
<meta name="twitter:description" content="对于 Glide 相信大家都不陌生，它是 Google 员工 bumptech 开源的一款图片加载框架，因为其简单易用的 API ，强大的功能，优秀的内存管理被 Google 官方所推荐并且被广泛运用在 Google 的开源项目中。目前 Glide 、Picasso 和 Fresco 都是比较主流图片加载框架。
它们的使用场景基本都是重合的，而本人对 Glide 更为熟悉，所以选取 Glide 来">
<meta name="twitter:image" content="http://o8swcawjo.bkt.clouddn.com/glideprocress.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hefuyicoder.com/2017/04/27/Glide源码解析（一）：加载流程/"/>





  <title>Glide源码解析（一）：加载流程 | 乌有先生的个人博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">乌有先生的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://hefuyicoder.com/2017/04/27/Glide源码解析（一）：加载流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乌有先生">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌有先生的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Glide源码解析（一）：加载流程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-27T00:00:00+08:00">
                2017-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/27/Glide源码解析（一）：加载流程/" class="leancloud_visitors" data-flag-title="Glide源码解析（一）：加载流程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>对于 Glide 相信大家都不陌生，它是 Google 员工 bumptech 开源的一款图片加载框架，因为其简单易用的 API ，强大的功能，优秀的内存管理被 Google 官方所推荐并且被广泛运用在 Google 的开源项目中。目前 Glide 、Picasso 和 Fresco 都是比较主流图片加载框架。</p>
<p>它们的使用场景基本都是重合的，而本人对 Glide 更为熟悉，所以选取 Glide 来进行深入学习，这系列文章作为学习的总结。选取的 Glide 版本是比较新的稳定版 3.7.0 。</p>
<p>本篇是源码解析的开篇，主要分析 Glide 加载图片的基本流程。在后续的专题中再对缓存机制、生命周期监听等细节进行详细分析。</p>
<a id="more"></a>
<h3 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h3><p>为了预防直接扎进源码的海洋带来的各种不适，做一下热身还是很有必要的。我们先抛开源码，从感性角度理解 Glide 成功显示出一张图片，需要经过哪些过程,由什么角色完成，这些角色有机结合起来就是整个基本流程了。</p>
<ul>
<li>数据源。即对数据来源的描述，要加载图片，当然需要告诉 Glide 从哪里获取了。它可以是 URL ，资源 ID 或者是一个文件。Glide 中称之为 Model。</li>
<li>从数据源中获取原始数据。一般是 InputStream ，Glide 中称之为 Data。负责从数据源中获取原始数据的角色称为 ModelLoader。</li>
<li>对原始数据解码。例如将 InputStream 解码为 Bitmap 或者 GifDrawable。解码后的资源称为 Resource。完成解码的角色称为 ResourceDecoder。</li>
<li>转码。Glide 除了能加载静图外，还能加载动图 Gif 。但是解码后静图类型 Bitmap 与 GifDrawable 并不统一。为了逻辑方便处理，Glide 会将 Bitmap 转码成 GlideBitmapDrawable。这样类型就能统一了，都是 GlideDrawable。负责转码的角色称为 Transcoder。</li>
<li>变换。根据图片设置的 ScaleType，做 FitCenter、CenterCrop 等转换。 在 Glide 中用 ResourceTranscoder 表示。</li>
<li>将图片显示到目标如 ImageView 上，Glide 将显示目标封装为 Target。</li>
</ul>
<p>到这里已经从概念上梳理清楚 Glide 图片加载的大概流程了，这是抹去了大量细节的描述，但是记住这个流程在阅读源码时就能知道当前所在环节而不轻易迷失方向。</p>
<p><img src="http://o8swcawjo.bkt.clouddn.com/glideprocress.png" alt="加载流程"></p>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>Glide 最基本的用法就是三步：with()再load()最后into()。下面从with()开始分析。</p>
<h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>with()方法是 Glide 中的一组静态方法，有多个类型不同的重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//RequestManager负责管理请求，具体是通过 Activity、Fragment的生命周期或网络连接的改变来智能地 start/stop/restart 请求。</span><br><span class="line">public static RequestManager with(Context context) &#123;</span><br><span class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">    return retriever.get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static RequestManager with(Activity activity) &#123;</span><br><span class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">    return retriever.get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static RequestManager with(FragmentActivity activity) &#123;</span><br><span class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">    return retriever.get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">public static RequestManager with(android.app.Fragment fragment) &#123;</span><br><span class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">    return retriever.get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static RequestManager with(Fragment fragment) &#123;</span><br><span class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">    return retriever.get(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是with()的全部重载方法，with()方法可接受的参数类型很多，包括 Context、Activity、FragmentActivity和Fragment，这样就可以灵活的根据当前上下文进行选择。同时不同的参数会对图片加载的生命周期产生影响。这些重载方法的内部实现都比较简单，先调用RequestManagerRetriever类的静态get()方法，该方法返回RequestManagerRetriever的单例实现。然后调用该实例的get()重载方法，最终返回一个RequestManager。</p>
<p>RequestManager负责管理请求，具体是通过 Activity、Fragment的生命周期或网络连接的改变来智能地 start/stop/restart 请求。</p>
<p>下面看看 get()方法的内部逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">public class RequestManagerRetriever implements Handler.Callback &#123;</span><br><span class="line"></span><br><span class="line">    /** The singleton instance of RequestManagerRetriever. */</span><br><span class="line">    private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever();</span><br><span class="line"></span><br><span class="line">    /** The top application level RequestManager. */</span><br><span class="line">    private volatile RequestManager applicationManager;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Retrieves and returns the RequestManagerRetriever singleton.</span><br><span class="line">     */</span><br><span class="line">    public static RequestManagerRetriever get() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private RequestManager getApplicationManager(Context context) &#123;</span><br><span class="line">        // Either an application context or we&apos;re on a background thread.</span><br><span class="line">        if (applicationManager == null) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (applicationManager == null) &#123;</span><br><span class="line">                    // Normally pause/resume is taken care of by the fragment we add to the fragment or activity.</span><br><span class="line">                    // However, in this case since the manager attached to the application will not receive lifecycle</span><br><span class="line">                    // events, we must force the manager to start resumed using ApplicationLifecycle.</span><br><span class="line">                    applicationManager = new RequestManager(context.getApplicationContext(),</span><br><span class="line">                            new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return applicationManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RequestManager get(Context context) &#123;</span><br><span class="line">        if (context == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);</span><br><span class="line">        &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;</span><br><span class="line">            if (context instanceof FragmentActivity) &#123;</span><br><span class="line">                return get((FragmentActivity) context);</span><br><span class="line">            &#125; else if (context instanceof Activity) &#123;</span><br><span class="line">                return get((Activity) context);</span><br><span class="line">            &#125; else if (context instanceof ContextWrapper) &#123;</span><br><span class="line">                return get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return getApplicationManager(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RequestManager get(FragmentActivity activity) &#123;</span><br><span class="line">        //如果当前不是运行在主线程</span><br><span class="line">        if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">            return get(activity.getApplicationContext());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            assertNotDestroyed(activity);</span><br><span class="line">            FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">            return supportFragmentGet(activity, fm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RequestManager get(Fragment fragment) &#123;</span><br><span class="line">        if (fragment.getActivity() == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;You cannot start a load on a fragment before it is attached&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">            return get(fragment.getActivity().getApplicationContext());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            FragmentManager fm = fragment.getChildFragmentManager();</span><br><span class="line">            return supportFragmentGet(fragment.getActivity(), fm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TargetApi(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">    public RequestManager get(Activity activity) &#123;</span><br><span class="line">        if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">            return get(activity.getApplicationContext());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            assertNotDestroyed(activity);</span><br><span class="line">            android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">            return fragmentGet(activity, fm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)</span><br><span class="line">    private static void assertNotDestroyed(Activity activity) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1 &amp;&amp; activity.isDestroyed()) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;You cannot start a load for a destroyed activity&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)</span><br><span class="line">    public RequestManager get(android.app.Fragment fragment) &#123;</span><br><span class="line">        if (fragment.getActivity() == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;You cannot start a load on a fragment before it is attached&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN_MR1) &#123;</span><br><span class="line">            return get(fragment.getActivity().getApplicationContext());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            android.app.FragmentManager fm = fragment.getChildFragmentManager();</span><br><span class="line">            return fragmentGet(fragment.getActivity(), fm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)</span><br><span class="line">    RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) &#123;</span><br><span class="line">        RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">        if (current == null) &#123;</span><br><span class="line">            current = pendingRequestManagerFragments.get(fm);</span><br><span class="line">            if (current == null) &#123;</span><br><span class="line">                current = new RequestManagerFragment();</span><br><span class="line">                pendingRequestManagerFragments.put(fm, current);</span><br><span class="line">                fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">                handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TargetApi(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">    RequestManager fragmentGet(Context context, android.app.FragmentManager fm) &#123;</span><br><span class="line">        RequestManagerFragment current = getRequestManagerFragment(fm);</span><br><span class="line">        RequestManager requestManager = current.getRequestManager();</span><br><span class="line">        if (requestManager == null) &#123;</span><br><span class="line">            requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">            current.setRequestManager(requestManager);</span><br><span class="line">        &#125;</span><br><span class="line">        return requestManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm) &#123;</span><br><span class="line">        SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(</span><br><span class="line">            FRAGMENT_TAG);</span><br><span class="line">        if (current == null) &#123;</span><br><span class="line">            current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">            if (current == null) &#123;</span><br><span class="line">                current = new SupportRequestManagerFragment();</span><br><span class="line">                pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">                fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">                ///在主线程中将刚添加的SupportRequestManagerFragment从pending中移除</span><br><span class="line">                handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RequestManager supportFragmentGet(Context context, FragmentManager fm) &#123;</span><br><span class="line">        SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm);</span><br><span class="line">        RequestManager requestManager = current.getRequestManager();</span><br><span class="line">        if (requestManager == null) &#123;</span><br><span class="line">            requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">            current.setRequestManager(requestManager);</span><br><span class="line">        &#125;</span><br><span class="line">        return requestManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get() 也有多个重载方法，不过实际上就是两种情况：Application类型和非Application类型。</p>
<p>当传入的参数是 Application 类型时，就调用 getApplicationManager() 方法获取一个 RequestManager 对象，这是最简单的一种情况，因为 Application 的生命周期也就是应用程序的生命周期，RequestManager 不需要特地去管理 Request 的生命周期。</p>
<p>当传入的参数是非 Application 类型时，先用当前的 Activity 或 Fragment 获取 FragmentManager。然后调用重载的 fragmentGet() 方法来获取 ResuqstManager。</p>
<p>fragmentGet() 方法的内部逻辑并不复杂，首先是调用 getRequestManagerFragment() 方法创建一个 RequestManagerFragment，然后创建一个 RequestManager 并且将两者绑定，最后返回 RequestManager 实例。</p>
<p>为什么要创建 RequestManagerFragment 呢？它和 RequestManager 是什么关系？其实是为了监听 Activity 的生命周期事件来达到管理图片加载的生命周期。一个 RequestManagerFragment 和一个 RequestManager 对应。RequestManagerFragment 是一个无界面的 Fragment ，通过 FragmentManager 添加到当前 Activity 或 Fragment 下，通过这样一个隐藏的 Fragment 就能知道当前 Activity 的生命周期了。而 RequestManager 在 RequestManagerFragment 中注册了回调接口。这样就能通过监听 Activity 或 Fragment 的 onStart 、onStop 、onDestory 回调来发起、暂停、取消加载请求。这是 Glide 中的巧妙设计之一。</p>
<p>with() 部分的源码就到此结束，没有复杂的逻辑，主要是为了获取一个能够监听生命周期的 RequestManager 对象。可见漫漫长路才开始了一小步。</p>
<h4 id="load"><a href="#load" class="headerlink" title="load"></a>load</h4><p>经过 with() 方法，我们获得了一个 RequestManager 对象。接下来我们看看 load() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns a request builder to load the given &#123;@link File&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @see #fromFile()</span><br><span class="line">     * @see #load(Object)</span><br><span class="line">     *</span><br><span class="line">     * @param file The File containing the image</span><br><span class="line">     */</span><br><span class="line">    public DrawableTypeRequest&lt;File&gt; load(File file) &#123;</span><br><span class="line">        return (DrawableTypeRequest&lt;File&gt;) fromFile().load(file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Returns a request builder to load the given resource id.</span><br><span class="line">     *</span><br><span class="line">     * @see #fromResource()</span><br><span class="line">     * @see #load(Object)</span><br><span class="line">     *</span><br><span class="line">     * @param resourceId the id of the resource containing the image</span><br><span class="line">     */</span><br><span class="line">    public DrawableTypeRequest&lt;Integer&gt; load(Integer resourceId) &#123;</span><br><span class="line">        return (DrawableTypeRequest&lt;Integer&gt;) fromResource().load(resourceId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Returns a request builder to load the given &#123;@link java.lang.String&#125;.</span><br><span class="line">     * signature.</span><br><span class="line">     *</span><br><span class="line">     * @see #fromString()</span><br><span class="line">     * @see #load(Object)</span><br><span class="line">     *</span><br><span class="line">     * @param string A file path, or a uri or url handled by &#123;@link com.bumptech.glide.load.model.UriLoader&#125;.</span><br><span class="line">     */</span><br><span class="line">    public DrawableTypeRequest&lt;String&gt; load(String string) &#123;</span><br><span class="line">        return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Returns a request builder to load the given &#123;@link Uri&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @see #fromUri()</span><br><span class="line">     * @see #load(Object)</span><br><span class="line">     *</span><br><span class="line">     * @param uri The Uri representing the image. Must be of a type handled by</span><br><span class="line">     * &#123;@link com.bumptech.glide.load.model.UriLoader&#125;.</span><br><span class="line">     */</span><br><span class="line">    public DrawableTypeRequest&lt;Uri&gt; load(Uri uri) &#123;</span><br><span class="line">        return (DrawableTypeRequest&lt;Uri&gt;) fromUri().load(uri);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>load() 也有多个重载方法，能接受文件、资源ID、字符串和 Uri 作为输入进而加载图片。这里我就选取最常见的用 URL 字符串输入来分析。只有简短的一行代码，链式调用了fromString() 方法和 load() 方法。先来看看 fromString() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public DrawableTypeRequest&lt;String&gt; fromString() &#123;</span><br><span class="line">    return loadGeneric(String.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) &#123;</span><br><span class="line">    ///对于 string,int,integer,file,uri ,glide对每种modelclass都注册了将其转化为InputStream和ParcelFileDescriptor的ModelLoaderFactory</span><br><span class="line">    ///从注册的ModelLoaderFactory中查找string -&gt; stream 的 modelloader 得到StreamStringLoader</span><br><span class="line">    ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);</span><br><span class="line">    ///从注册的ModelLoaderFactory查找 string -&gt; filedescriptor 的modelloader 得到FileDescriptorStringLoader</span><br><span class="line">    ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader =</span><br><span class="line">            Glide.buildFileDescriptorModelLoader(modelClass, context);</span><br><span class="line">    if (modelClass != null &amp;&amp; streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Unknown type &quot; + modelClass + &quot;. You must provide a Model of a type for&quot;</span><br><span class="line">                + &quot; which there is a registered ModelLoader, if you are using a custom model, you must first call&quot;</span><br><span class="line">                + &quot; Glide#register with a ModelLoaderFactory for your custom model class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return optionsApplier.apply(</span><br><span class="line">            new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,glide, requestTracker, lifecycle, optionsApplier));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fromString() 方法内部调用了 loadGeneric() 方法，loadGeneric() 方法返回了一个 DrawableTypeRequest 对象。</p>
<p>DrawableTypeRequest 的继承关系如下</p>
<p><img src="http://o8swcawjo.bkt.clouddn.com/DrawableTypeRequest.png" alt="DrawableTypeRequest"></p>
<p>可见它负责创建加载请求，同时也代表一个加载 Drawable 的请求。现在回到上段代码，看看它是如何创建出来的。</p>
<p>第一步，先是调用了 Glide 的静态方法 buildStreamModelLoader() 和 buildFileDescriptorModelLoader() 来获得两个 ModelLoader。回想一下预热部分的内容，ModelLoader 是负责从数据源中获取原始数据的，这里分别获得了从 String 表示的 URL 中取得 InputStream 和 ParcelFileDescriptor 的 ModelLoader。</p>
<p>实际上，Glide 在初始化的时候,对于每种类型的输入：String、int、Integer、File、Uri，都注册了能够将它们转化为 InputStream 和 ParcelFileDescriptor 的 ModelLoader，保存在HashMap中。这两个 buildxxxModelLoader() 方法实际上就是从 HashMap 中获取对应的 ModelLoader。在当前情景下，获取到的是 StreamStringLoader 和 FileDescriptorStringLoader。</p>
<p>第二步，用刚刚获取的 StreamStringLoader 和 FileDescriptorStringLoader 作为构造参数来创建 DrawableTypeRequest。还有其他一些参数，这里暂且先不关注。</p>
<p>回到 RequestManager 的 load() 方法，接下来执行 fromString() 返回的 DrawableTypeRequest 的 load() 方法。DrawableTypeRequest 没有 load() 方法，因此实际上执行的是其父类 DrawableRequestBuilder 的 load() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">===DrawableRequestBuilder.java===</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public DrawableRequestBuilder&lt;ModelType&gt; load(ModelType model) &#123;</span><br><span class="line">    super.load(model);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===GenericRequestBuilder.java===</span><br><span class="line"></span><br><span class="line">public GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; load(ModelType model) &#123;</span><br><span class="line">    this.model = model;</span><br><span class="line">    isModelSet = true;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是做了简单的赋值操作，这里就不多做解释了。</p>
<p>第二步 load() 至此也结束了，目前我们得到了一个 DrawableTypeRequest 对象。第三步 into() 将围绕这个对象展开。</p>
<h4 id="into"><a href="#into" class="headerlink" title="into"></a>into</h4><p>接下来接着看 DrawableTypeRequest 的 into() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Target&lt;GlideDrawable&gt; into(ImageView view) &#123;</span><br><span class="line">    return super.into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的逻辑在其父类 GenericRequestBuilder 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Sets the &#123;@link ImageView&#125; the resource will be loaded into, cancels any existing loads into the view, and frees</span><br><span class="line"> * any resources Glide may have previously loaded into the view so they may be reused.</span><br><span class="line"> *</span><br><span class="line"> * @see Glide#clear(android.view.View)</span><br><span class="line"> *</span><br><span class="line"> * @param view The view to cancel previous loads for and load the new resource into.</span><br><span class="line"> * @return The &#123;@link com.bumptech.glide.request.target.Target&#125; used to wrap the given &#123;@link ImageView&#125;.</span><br><span class="line"> */</span><br><span class="line">public Target&lt;TranscodeType&gt; into(ImageView view) &#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    if (view == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;You must pass in a non null View&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!isTransformationSet &amp;&amp; view.getScaleType() != null) &#123;</span><br><span class="line">        switch (view.getScaleType()) &#123;</span><br><span class="line">            case CENTER_CROP:</span><br><span class="line">                //导致transformation中保存一个类型为centerCrop的transformation,并且isTransformationSet设为true</span><br><span class="line">                applyCenterCrop();</span><br><span class="line">                break;</span><br><span class="line">            case FIT_CENTER:</span><br><span class="line">            case FIT_START:</span><br><span class="line">            case FIT_END:</span><br><span class="line">                applyFitCenter();</span><br><span class="line">                break;</span><br><span class="line">            //$CASES-OMITTED$</span><br><span class="line">            default:</span><br><span class="line">                // Do nothing.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ///transcodeClass用来标记imageview的使用bitmap还是drawable还是glidedrawable。返回不同实例的ImageViewTarget</span><br><span class="line">    return into(glide.buildImageViewTarget(view, transcodeClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先 Glide 根据 ImageView 的 ScaleType 来对图片进行相应的变换。这里选取 CENTER_CROP 的场景作为例子进行分析。来看看 applyCenterCrop() 方法。</p>
<p>applyCenterCrop() 的实现在具体的子类中，在当前场景下就是 DrawableTypeRequest。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">===DrawableTypeRequest.java===</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"> void applyCenterCrop() &#123;</span><br><span class="line">     centerCrop();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public DrawableRequestBuilder&lt;ModelType&gt; centerCrop() &#123;</span><br><span class="line">     return transform(glide.getDrawableCenterCrop());</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public DrawableRequestBuilder&lt;ModelType&gt; transform(Transformation&lt;GifBitmapWrapper&gt;... transformation) &#123;</span><br><span class="line">     super.transform(transformation);</span><br><span class="line">     return this;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ===GenericRequestBuilder.java===</span><br><span class="line"> </span><br><span class="line"> public GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; transform(</span><br><span class="line">         Transformation&lt;ResourceType&gt;... transformations) &#123;</span><br><span class="line">     isTransformationSet = true;</span><br><span class="line">     if (transformations.length == 1) &#123;</span><br><span class="line">         transformation = transformations[0];</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         transformation = new MultiTransformation&lt;ResourceType&gt;(transformations);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return this;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>嵌套比较多，我抽取出了上面的相关方法。</p>
<p>在 DrawableTypeRequest 的 centerCrop() 方法中调用了 Glide 的 glide.getDrawableCenterCrop() 获取一个 Transformation 实例。预热部分提到，Transformation 负责对图片进行 CenterCrop、FitCenter 等转化。此处会获取到一个 GifBitmapWrapperTransformation,其内部封装了对 Bitmap 执行转化的 BitmapTransformation 和一个对 GifDrawable 执行变换的 GifDrawableTransformation。</p>
<p>经过层层嵌套，最终会执行父类 GenericRequestBuilder 的 transform() 方法，该方法将 isTransformationSet 置为 true，并且将 Transformation 实例保存到 transformation 变量中。可见这里只是做了相关的赋值操作，真正的图片变换将在后面合适的时机进行。</p>
<p>回到 GenericRequestBuilder 的 into() 方法，记录下该图片需要进行的转化之后，调用了 Glide 的 buildImageViewTarget() 来构建一个 ImageViewTarget，然后使用 ImageViewTarget 作为参数执行 into() 方法。</p>
<p>Target 是一个接口，Glide 将可以接收图片的目标封装成一个 Target 对象，并且 Target 包含 onLoadStarted、onResourceReady、onLoadCleared、onLoadFailed 等方法来显示不同的内容。</p>
<p>我们接着看看 buildImageViewTarget() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   ===Glide.java===</span><br><span class="line">    &lt;R&gt; Target&lt;R&gt; buildImageViewTarget(ImageView imageView, Class&lt;R&gt; transcodedClass) &#123;</span><br><span class="line">        return imageViewTargetFactory.buildTarget(imageView, transcodedClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    === ImageViewTargetFactory.java===</span><br><span class="line">    </span><br><span class="line">    public class ImageViewTargetFactory &#123;</span><br><span class="line"></span><br><span class="line">    //这个class参数其实基本上只有两种情况，如果你在使用Glide加载图片的时候调用了asBitmap()方法，</span><br><span class="line">    //那么这里就会构建出BitmapImageViewTarget对象，否则的话构建的都是GlideDrawableImageViewTarget对象。</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;Z&gt; Target&lt;Z&gt; buildTarget(ImageView view, Class&lt;Z&gt; clazz) &#123;</span><br><span class="line">        if (GlideDrawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            return (Target&lt;Z&gt;) new GlideDrawableImageViewTarget(view);</span><br><span class="line">        &#125; else if (Bitmap.class.equals(clazz)) &#123;</span><br><span class="line">            return (Target&lt;Z&gt;) new BitmapImageViewTarget(view);</span><br><span class="line">        &#125; else if (Drawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            return (Target&lt;Z&gt;) new DrawableImageViewTarget(view);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unhandled class: &quot; + clazz</span><br><span class="line">                    + &quot;, try .as*(Class).transcode(ResourceTranscoder)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的 Target 具体实例取决于 transcodedClass 参数，该参数由 DrawableTypeRequest 传入，具体来说就是 GlideDrawable.class。而如果你在 Glide.with().load() 之后加上了 asBitmap()，将得到一个 BitmapTypeRequest,那么 transcodedClass 参数将是 Bitmap.class。如果加上了 asGif() ,将得到一个 GifTypeRequest，那么 transcodedClass 参数将是 GifDrawable。实际上他们都是 GenericRequestBuilder 的子类，关系如下：</p>
<p><img src="http://o8swcawjo.bkt.clouddn.com/GenericRequestBuilder.png" alt="GenericRequestBuilder"></p>
<p>简单来说，默认情况下 buildImageViewTarget 将返回一个 GlideDrawableImageViewTarget 实例，除非你调用了 asBitmap(),那么将返回一个 BitmapImageViewTarget 实例。在当前情景下，我们获取到的是前者。</p>
<p>回到 GenericRequestBuilder 的 into() 方法，刚刚我们构建了一个 GlideDrawableImageViewTarget 对象，接下来它将作为参数来执行重载的 into() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//清除target绑定的旧request,新建一个request并绑定到target。将request传递到requestTracker的runRequest方法中</span><br><span class="line">public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) &#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    if (target == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;You must pass in a non null Target&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isModelSet) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;You must first set a model (try #load())&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line"></span><br><span class="line">    if (previous != null) &#123;</span><br><span class="line">        previous.clear();///回收资源,设置状态,设置placeholder</span><br><span class="line">        requestTracker.removeRequest(previous);///意味着就request不再受生命周期回调影响</span><br><span class="line">        previous.recycle();///成员属性置null,回收到REQUEST_POOL,以供复用</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request request = buildRequest(target);</span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    lifecycle.addListener(target);</span><br><span class="line">    requestTracker.runRequest(request);</span><br><span class="line"></span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要是构建了一个 Request 对象然后执行。首先 target.getRequest() 取出与 target 对象绑定的 Request 对象。Glide 通过 View 的 setTag() 方法将特定的 View 和其对应的图片加载请求绑定在一起。这样做的好处是能够容易地判断 Target 所封装的 View 是否被复用，复用时先取消之前的请求，避免了不必要的请求，也能防止图片错位。如果没有之前绑定的请求，说明该 View 没有被复用，那么调用 buildRequest() 创建一个 Request 对象，然后通过 requestTracker.runRequest 交给 RequestTracker 去执行。</p>
<p>下面先看下 Request 是如何构建出来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private Request buildRequest(Target&lt;TranscodeType&gt; target) &#123;</span><br><span class="line">    if (priority == null) &#123;</span><br><span class="line">        priority = Priority.NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">    return buildRequestRecursive(target, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Request buildRequestRecursive(Target&lt;TranscodeType&gt; target, ThumbnailRequestCoordinator parentCoordinator) &#123;</span><br><span class="line">    if (thumbnailRequestBuilder != null) &#123;</span><br><span class="line">        if (isThumbnailBuilt) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;You cannot use a request as both the main request and a thumbnail, &quot;</span><br><span class="line">                    + &quot;consider using clone() on the request(s) passed to thumbnail()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // Recursive case: contains a potentially recursive thumbnail request builder.</span><br><span class="line">        if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) &#123;</span><br><span class="line">            thumbnailRequestBuilder.animationFactory = animationFactory;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (thumbnailRequestBuilder.priority == null) &#123;</span><br><span class="line">            thumbnailRequestBuilder.priority = getThumbnailPriority();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Util.isValidDimensions(overrideWidth, overrideHeight)</span><br><span class="line">                &amp;&amp; !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth,</span><br><span class="line">                        thumbnailRequestBuilder.overrideHeight)) &#123;</span><br><span class="line">          thumbnailRequestBuilder.override(overrideWidth, overrideHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);</span><br><span class="line">        Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);</span><br><span class="line">        // Guard against infinite recursion.</span><br><span class="line">        isThumbnailBuilt = true;</span><br><span class="line">        // Recursively generate thumbnail requests.</span><br><span class="line">        Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator);</span><br><span class="line">        isThumbnailBuilt = false;</span><br><span class="line">        coordinator.setRequests(fullRequest, thumbRequest);</span><br><span class="line">        return coordinator;</span><br><span class="line">    &#125; else if (thumbSizeMultiplier != null) &#123;</span><br><span class="line">        // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.</span><br><span class="line">        ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);</span><br><span class="line">        Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);</span><br><span class="line">        Request thumbnailRequest = obtainRequest(target, thumbSizeMultiplier, getThumbnailPriority(), coordinator);</span><br><span class="line">        coordinator.setRequests(fullRequest, thumbnailRequest);</span><br><span class="line">        return coordinator;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Base case: no thumbnail.</span><br><span class="line">        ///parentCoordinator是null</span><br><span class="line">        return obtainRequest(target, sizeMultiplier, priority, parentCoordinator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>buildRequest() 方法内部调用了 buildRequestRecursive() 方法。buildRequestRecursive() 方法中有三个分支，前两个分支与略缩图有关，当前情景下会进入到第三个分支，仅仅是调用了 obtainRequest() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private Request obtainRequest(Target&lt;TranscodeType&gt; target, float sizeMultiplier, Priority priority,</span><br><span class="line">        RequestCoordinator requestCoordinator) &#123;</span><br><span class="line">    return GenericRequest.obtain(</span><br><span class="line">            loadProvider,</span><br><span class="line">            model,</span><br><span class="line">            signature,</span><br><span class="line">            context,</span><br><span class="line">            priority,</span><br><span class="line">            target,</span><br><span class="line">            sizeMultiplier,</span><br><span class="line">            placeholderDrawable,</span><br><span class="line">            placeholderId,</span><br><span class="line">            errorPlaceholder,</span><br><span class="line">            errorId,</span><br><span class="line">            fallbackDrawable,</span><br><span class="line">            fallbackResource,</span><br><span class="line">            requestListener,</span><br><span class="line">            requestCoordinator,</span><br><span class="line">            glide.getEngine(),</span><br><span class="line">            transformation,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            isCacheable,</span><br><span class="line">            animationFactory,</span><br><span class="line">            overrideWidth,</span><br><span class="line">            overrideHeight,</span><br><span class="line">            diskCacheStrategy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>obtainRequest() 方法内部又去调用了 GenericRequest 静态的 obtain() 方法来获取 Request。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;A, T, Z, R&gt; GenericRequest&lt;A, T, Z, R&gt; obtain(</span><br><span class="line">        LoadProvider&lt;A, T, Z, R&gt; loadProvider,</span><br><span class="line">        A model,</span><br><span class="line">        Key signature,</span><br><span class="line">        Context context,</span><br><span class="line">        Priority priority,</span><br><span class="line">        Target&lt;R&gt; target,</span><br><span class="line">        float sizeMultiplier,</span><br><span class="line">        Drawable placeholderDrawable,</span><br><span class="line">        int placeholderResourceId,</span><br><span class="line">        Drawable errorDrawable,</span><br><span class="line">        int errorResourceId,</span><br><span class="line">        Drawable fallbackDrawable,</span><br><span class="line">        int fallbackResourceId,</span><br><span class="line">        RequestListener&lt;? super A, R&gt; requestListener,</span><br><span class="line">        RequestCoordinator requestCoordinator,</span><br><span class="line">        Engine engine,</span><br><span class="line">        Transformation&lt;Z&gt; transformation,</span><br><span class="line">        Class&lt;R&gt; transcodeClass,</span><br><span class="line">        boolean isMemoryCacheable,</span><br><span class="line">        GlideAnimationFactory&lt;R&gt; animationFactory,</span><br><span class="line">        int overrideWidth,</span><br><span class="line">        int overrideHeight,</span><br><span class="line">        DiskCacheStrategy diskCacheStrategy) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    GenericRequest&lt;A, T, Z, R&gt; request = (GenericRequest&lt;A, T, Z, R&gt;) REQUEST_POOL.poll();</span><br><span class="line">    if (request == null) &#123;</span><br><span class="line">        request = new GenericRequest&lt;A, T, Z, R&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    request.init(loadProvider,</span><br><span class="line">            model,</span><br><span class="line">            signature,</span><br><span class="line">            context,</span><br><span class="line">            priority,</span><br><span class="line">            target,</span><br><span class="line">            sizeMultiplier,</span><br><span class="line">            placeholderDrawable,</span><br><span class="line">            placeholderResourceId,</span><br><span class="line">            errorDrawable,</span><br><span class="line">            errorResourceId,</span><br><span class="line">            fallbackDrawable,</span><br><span class="line">            fallbackResourceId,</span><br><span class="line">            requestListener,</span><br><span class="line">            requestCoordinator,</span><br><span class="line">            engine,</span><br><span class="line">            transformation,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            animationFactory,</span><br><span class="line">            overrideWidth,</span><br><span class="line">            overrideHeight,</span><br><span class="line">            diskCacheStrategy);</span><br><span class="line">    return request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有可复用的 Request,那么将会创建一个 GenericRequest 实例，它是 Request 接口的实现。然后调用了该实例的 init() 方法，里面主要是做一些赋值操作，就不展开了。</p>
<p>现在我们拥有了一个 GenericRequest 实例，接下来它将交给 RequestTracker 的 runRequest() 方法执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void runRequest(Request request) &#123;</span><br><span class="line">    requests.add(request);</span><br><span class="line">    if (!isPaused) &#123;</span><br><span class="line">        request.begin();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestTracker 调用了 Request 实例的 begin() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void begin() &#123;</span><br><span class="line">     startTime = LogTime.getLogTime();</span><br><span class="line">     if (model == null) &#123;</span><br><span class="line">         onException(null);</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     status = Status.WAITING_FOR_SIZE;</span><br><span class="line">     if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">         ///如果使用了override() API为图片指定了一个固定的宽高</span><br><span class="line">         onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         //没有指定</span><br><span class="line">         //内部使用Determiner先尝试获取view.getWidth/view.getHight,如果两者都为0,那么检查layoutparam是否为空,如果也为空,就在view的ViewTreeObserver上添加OnPreDrawListener,在回调方法中再次去检查。</span><br><span class="line">         // 在计算完之后，它也会调用onSizeReady()方法</span><br><span class="line">         target.getSize(this);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ///设置占位图</span><br><span class="line">     if (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">         target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">     &#125;</span><br><span class="line">     if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">         logV(&quot;finished run method in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码主要尝试去确定当前请求的图片大小，同时给 Target 设置占位图。</p>
<p>当前图片请求的大小是否已经指定取决于是否使用了 override() 方法，如果已经指定则调用 onSizeReady() 做进一步操作，如果还没有指定，则调用 getSize() 方法来确定 ImageView 的实际大小。getSize() 方法内部使用 SizeDeterminer 辅助类，依次从 view.getWidth/view.getHight、layoutparam 获取，如果还不能确定，说明该 View 还没有 measure 完毕。那么就在该 View 的ViewTreeObserver 添加 OnPreDrawListener，当整个 view tree measure 完毕即将 draw 时会收到 onPreDraw() 方法回调，这时再重新确定 View 的大小。确定好大小后会调用 onSizeReady() 方法。</p>
<p>同时，会调用 getPlaceholderDrawable() 方法获取占位图 然后调用 Target 的 onLoadStarted() 方法来设置占位图，我们来看一下内部细节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">===GenericRequest.java===</span><br><span class="line"></span><br><span class="line">private Drawable getPlaceholderDrawable() &#123;</span><br><span class="line">    if (placeholderDrawable == null &amp;&amp; placeholderResourceId &gt; 0) &#123;</span><br><span class="line">        placeholderDrawable = context.getResources().getDrawable(placeholderResourceId);</span><br><span class="line">    &#125;</span><br><span class="line">    return placeholderDrawable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===ImageViewTarget.java===</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onLoadStarted(Drawable placeholder) &#123;</span><br><span class="line">    view.setImageDrawable(placeholder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终会调用 ImageView 对象的 setImageDrawable() 方法，这就是通过 placeholder() 设置占位图的原理。上面 begin() 代码中的<br>onException(null) 也是类似，看官们可以自行研究。</p>
<p>上面刚才说到确定图片大小之后会调用 onSizeReady() 方法，下面我们来看看它的内部逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void onSizeReady(int width, int height) &#123;</span><br><span class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logV(&quot;Got onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">    if (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    width = Math.round(sizeMultiplier * width);</span><br><span class="line">    height = Math.round(sizeMultiplier * height);</span><br><span class="line"></span><br><span class="line">    ///loadProvider是一个FixedLoadProvider，返回ImageVideoModelLoader</span><br><span class="line">    ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();</span><br><span class="line">    ///返回ImageVideoFetcher,其封装了StreamStringLoader和FileDescriptorStringlLoader的fetcher</span><br><span class="line">    final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);</span><br><span class="line"></span><br><span class="line">    if (dataFetcher == null) &#123;</span><br><span class="line">        onException(new Exception(&quot;Failed to load model: \&apos;&quot; + model + &quot;\&apos;&quot;));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ///GifBitmapWrapperDrawableTranscoder</span><br><span class="line">    ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();</span><br><span class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logV(&quot;finished setup for calling load in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">    loadedFromMemoryCache = true;</span><br><span class="line">    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,</span><br><span class="line">            priority, isMemoryCacheable, diskCacheStrategy, this);</span><br><span class="line">    loadedFromMemoryCache = resource != null;</span><br><span class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logV(&quot;finished onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要从 loadProvider 获取了 ModelLoader 和 ResourceTranscoder，然后传进 Engine 的 load() 方法中。</p>
<p>要读懂这段代码首先要明白 loadProvider 是什么东西？从何而来？经过层层回溯会发现，loadProvider 是从 DrawableTypeRequest 的构造函数传入的，我们回头看一下 DrawableTypeRequest 的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DrawableTypeRequest(Class&lt;ModelType&gt; modelClass, ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader,</span><br><span class="line">         ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Context context, Glide glide,</span><br><span class="line">         RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) &#123;</span><br><span class="line">     super(context, modelClass,</span><br><span class="line">             buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class,</span><br><span class="line">                     GlideDrawable.class, null),</span><br><span class="line">             glide, requestTracker, lifecycle);</span><br><span class="line">     this.streamModelLoader = streamModelLoader;</span><br><span class="line">     this.fileDescriptorModelLoader = fileDescriptorModelLoader;</span><br><span class="line">     this.optionsApplier = optionsApplier;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>DrawableTypeRequest 的构造函数中 调用 buildProvider 创建了一个 FixedLoadProvider，并将它作为参数调用了父类的构造函数，我们来看一下 buildProvider（）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">///A代表Model类型:String Z代表Resource类型:GifBitmapWrapper R代表转码后类型：GlideDrawable</span><br><span class="line">private static &lt;A, Z, R&gt; FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt; buildProvider(Glide glide,</span><br><span class="line">        ModelLoader&lt;A, InputStream&gt; streamModelLoader,</span><br><span class="line">        ModelLoader&lt;A, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Class&lt;Z&gt; resourceClass,</span><br><span class="line">        Class&lt;R&gt; transcodedClass,</span><br><span class="line">        ResourceTranscoder&lt;Z, R&gt; transcoder) &#123;</span><br><span class="line">    if (streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (transcoder == null) &#123;</span><br><span class="line">        ///Glide 为 GifBitmapWrapper -&gt; GlideDrawable 和 Bitmap -&gt; GlideBitmapDrawable 都注册了ResourceTranscoder</span><br><span class="line">        ///获取负责将 GifBitmapWrapper 转码成 GlideDrawable 的 ResourceTranscoder,这里获取到GifBitmapWrapperDrawableTranscoder</span><br><span class="line">        transcoder = glide.buildTranscoder(resourceClass, transcodedClass);</span><br><span class="line">    &#125;</span><br><span class="line">    /// DataLoadProvider 用于图片编解码,此处获取 ImageVideoWrapper 与 GifBitmapWrapper 编解码的 DataLoadProvider</span><br><span class="line">    // 得到的实例是ImageVideoGifDrawableLoadProvider</span><br><span class="line">    DataLoadProvider&lt;ImageVideoWrapper, Z&gt; dataLoadProvider = glide.buildDataProvider(ImageVideoWrapper.class,</span><br><span class="line">            resourceClass);</span><br><span class="line">    ///封装了 StreamStringLoader 和 FileDescriptorStringLoader</span><br><span class="line">    ImageVideoModelLoader&lt;A&gt; modelLoader = new ImageVideoModelLoader&lt;A&gt;(streamModelLoader,</span><br><span class="line">            fileDescriptorModelLoader);</span><br><span class="line">    ///这个也就是 onSizeReady() 方法中的 loadProvider</span><br><span class="line">    return new FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt;(modelLoader, transcoder, dataLoadProvider);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码已经附上了比较详细的注释。首先说明一下，DataLoadProvider 是一个接口，接口声明如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A load provider that provides the necessary encoders and decoders to decode a specific type of resource from a</span><br><span class="line"> * specific type of data.</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;T&gt; The type of data the resource will be decoded from.</span><br><span class="line"> * @param &lt;Z&gt; The type of resource that will be decoded.</span><br><span class="line"> */</span><br><span class="line">public interface DataLoadProvider&lt;T, Z&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the &#123;@link com.bumptech.glide.load.ResourceDecoder&#125; to use to decode the resource from the disk cache.</span><br><span class="line">     */</span><br><span class="line">    ResourceDecoder&lt;File, Z&gt; getCacheDecoder();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the &#123;@link com.bumptech.glide.load.ResourceDecoder&#125; to use to decode the resource from the original data.</span><br><span class="line">     */</span><br><span class="line">    ResourceDecoder&lt;T, Z&gt; getSourceDecoder();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the &#123;@link com.bumptech.glide.load.Encoder&#125; to use to write the original data to the disk cache.</span><br><span class="line">     */</span><br><span class="line">    Encoder&lt;T&gt; getSourceEncoder();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the &#123;@link com.bumptech.glide.load.ResourceEncoder&#125; to use to write the decoded and transformed resource</span><br><span class="line">     * to the disk cache.</span><br><span class="line">     */</span><br><span class="line">    ResourceEncoder&lt;Z&gt; getEncoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 DataLoadProvider 实例负责提供 Data 和 Resource 之间的编解码，解码表示从 Date 转化为 Resource 的过程，编码表示将 Date 或者 Resource 持久化为本地文件的过程，以实现磁盘缓存。所以 DataLoadProvider 提供了四个方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">getCacheDecoder</th>
<th style="text-align:center">getSourceDecoder</th>
<th style="text-align:center">getSourceEncoder</th>
<th style="text-align:center">getEncoder</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">返回类型</td>
<td style="text-align:center">ResourceDecoder</td>
<td style="text-align:center">ResourceDecoder</td>
<td style="text-align:center">Encoder</td>
<td style="text-align:center">ResourceEncoder</td>
</tr>
<tr>
<td style="text-align:center">转化前</td>
<td style="text-align:center">File</td>
<td style="text-align:center">Data</td>
<td style="text-align:center">Data</td>
<td style="text-align:center">Resource</td>
</tr>
<tr>
<td style="text-align:center">转化后</td>
<td style="text-align:center">Resource</td>
<td style="text-align:center">Resource</td>
<td style="text-align:center">File</td>
<td style="text-align:center">File</td>
</tr>
</tbody>
</table>
<p>这样一个 DataLoadProvider 实例就包办 Resource 的解码和缓存了。</p>
<p>Glide 提供了丰富的 DataLoadProvider 实例来实现各种类型之间的编解码</p>
<p><img src="http://o8swcawjo.bkt.clouddn.com/DataLoadProvider.png" alt="DataLoadProvider"></p>
<p>这里还要提一个接口 LoadProvider，它继承了 DataLoadProvider 接口，并新增了两个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface LoadProvider&lt;A, T, Z, R&gt; extends DataLoadProvider&lt;T, Z&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the &#123;@link com.bumptech.glide.load.model.ModelLoader&#125; to convert from the given model to a data type.</span><br><span class="line">     */</span><br><span class="line">    ModelLoader&lt;A, T&gt; getModelLoader();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the &#123;@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder&#125; to convert from the decoded</span><br><span class="line">     * and transformed resource into the transcoded resource.</span><br><span class="line">     */</span><br><span class="line">    ResourceTranscoder&lt;Z, R&gt; getTranscoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LoadProvider 接口新增了获取 ModelLoader 和 ResourceTranscoder 的两个方法。我们当前讨论的主角 FixedLoadProvider 就是 LoadProvider 的实例，它是多个 DataLoadProvider 实例的顶层封装 ，它与大部分的 DataLoadProvider 实例有着紧密的联系，它们之间的依赖关系如下</p>
<p><img src="http://o8swcawjo.bkt.clouddn.com/FixLoadProvider.png" alt="FixLoadProvider"></p>
<p>所以说，FixLoadProvider 提供了图片原始数据的获取、解码、编码、转码的一条龙服务！</p>
<p>回到 buildProvider() 那段代码，buildProvider() 方法中获取了 GifBitmapWrapperDrawableTranscoder 、ImageVideoGifDrawableLoadProvider 和 ImageVideoModelLoader，然后作为参数构建了一个 FixLoadProvider，这个也就是 onSizeReady() 方法中的 loadProvider 实例。</p>
<p>了解了 FixLoadProvider 之后，我们就可以回过头重新看看 onSizeReady() 方法了，这里重新贴一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void onSizeReady(int width, int height) &#123;</span><br><span class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logV(&quot;Got onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">    if (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    width = Math.round(sizeMultiplier * width);</span><br><span class="line">    height = Math.round(sizeMultiplier * height);</span><br><span class="line"></span><br><span class="line">    ///loadProvider是一个FixedLoadProvider，返回ImageVideoModelLoader</span><br><span class="line">    ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();</span><br><span class="line">    ///返回ImageVideoFetcher,其封装了StreamStringLoader和FileDescriptorStringlLoader的fetcher</span><br><span class="line">    final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);</span><br><span class="line"></span><br><span class="line">    if (dataFetcher == null) &#123;</span><br><span class="line">        onException(new Exception(&quot;Failed to load model: \&apos;&quot; + model + &quot;\&apos;&quot;));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ///GifBitmapWrapperDrawableTranscoder</span><br><span class="line">    ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();</span><br><span class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logV(&quot;finished setup for calling load in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">    loadedFromMemoryCache = true;</span><br><span class="line">    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,</span><br><span class="line">            priority, isMemoryCacheable, diskCacheStrategy, this);</span><br><span class="line">    loadedFromMemoryCache = resource != null;</span><br><span class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logV(&quot;finished onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里从 loadProvider 获取了刚刚提到的 ImageVideoModelLoader 和 GifBitmapWrapperDrawableTranscoder，还有从 ImageVideoModelLoader 中获取一个 DataFetcher 实例。getResourceFetcher() 是 ModelLoader 接口的唯一一个方法，返回一个真正执行原始数据获取的一个 DataFetcher 实例。最后 onSizeReady() 将一系列值传进 Engin 的 load() 方法中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Responsible for starting loads and managing active and cached resources.</span><br><span class="line"> */</span><br><span class="line">public class Engine implements EngineJobListener,</span><br><span class="line">        MemoryCache.ResourceRemovedListener,</span><br><span class="line">        EngineResource.ResourceListener &#123;</span><br><span class="line"></span><br><span class="line">    public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher,</span><br><span class="line">            DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span><br><span class="line">            Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) &#123;</span><br><span class="line">        Util.assertMainThread();</span><br><span class="line">        long startTime = LogTime.getLogTime();</span><br><span class="line"></span><br><span class="line">        final String id = fetcher.getId();</span><br><span class="line">        EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</span><br><span class="line">                loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</span><br><span class="line">                transcoder, loadProvider.getSourceEncoder());</span><br><span class="line"></span><br><span class="line">        EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">        if (cached != null) &#123;</span><br><span class="line">            cb.onResourceReady(cached);</span><br><span class="line">            if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">        if (active != null) &#123;</span><br><span class="line">            cb.onResourceReady(active);</span><br><span class="line">            if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EngineJob current = jobs.get(key);</span><br><span class="line">        if (current != null) &#123;</span><br><span class="line">            current.addCallback(cb);</span><br><span class="line">            if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);</span><br><span class="line">            &#125;</span><br><span class="line">            return new LoadStatus(cb, current);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ///EngineJob的主要作用就是用来开启线程的，为后面的异步加载图片做准备</span><br><span class="line">        EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class="line">        DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class="line">                transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class="line">        EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);</span><br><span class="line">        jobs.put(key, engineJob);</span><br><span class="line">        ///将GenericRequest的回调接口交给enginejob</span><br><span class="line">        engineJob.addCallback(cb);</span><br><span class="line">        ///实际上就是让EngineRunnable的run()方法在子线程当中执行</span><br><span class="line">        engineJob.start(runnable);</span><br><span class="line"></span><br><span class="line">        if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line">        return new LoadStatus(cb, engineJob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loadFromCache() 和 loadFromActiveResources() 与内存缓存有关，不是本文的重点，我们关注最下面这段就可以了。这里分别创建了 EngineJob 和 DecodeJob，并用来构建 EngineRunnable。</p>
<p>EngineJob 负责统一管理加载请求的 ResourceCallback，EngineJob 本身也实现了 ResourceCallback 接口，当加载请求完成时 EngineRunnable 回调 EngineJob 的 onResourceReady() 方法，EngineJob 在分发给所有的监听者。</p>
<p>DecodeJob 的工作特别繁重，负责了 Resource 的所有解码工作，包括从 Data 解码和从缓存解码，同时承担了解码之后的转换和转码工作。</p>
<p>最后把 EngineRunnable 交给 Engine 的 start() 方法执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void start(EngineRunnable engineRunnable) &#123;</span><br><span class="line">     this.engineRunnable = engineRunnable;</span><br><span class="line">     future = diskCacheService.submit(engineRunnable);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里交给了线程池去处理，那么 EngineRunnable 的 run() 方法将在子线程中运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class EngineRunnable implements Runnable, Prioritized &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (isCancelled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Exception exception = null;</span><br><span class="line">        Resource&lt;?&gt; resource = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ///最后会得到Resource&lt;GlideDrawable&gt;实例</span><br><span class="line">            resource = decode();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                Log.v(TAG, &quot;Exception decoding&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">            exception = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (isCancelled) &#123;</span><br><span class="line">            if (resource != null) &#123;</span><br><span class="line">                resource.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (resource == null) &#123;</span><br><span class="line">            /// 第一次走decode()尝试从磁盘获取,失败后会走这里。重新进入decode</span><br><span class="line">            onLoadFailed(exception);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            onLoadComplete(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的重点是 decode() 方法，它将返回一个 Resource 实例对象，那么我们看看它的内部逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Resource&lt;?&gt; decode() throws Exception &#123;</span><br><span class="line">     if (isDecodingFromCache()) &#123;</span><br><span class="line">         ///从磁盘缓存中decode图片,第一次会走这</span><br><span class="line">         return decodeFromCache();</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         ///从源中decode图片,第二次会走这</span><br><span class="line">         return decodeFromSource();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>第一次进入该方法时 isDecodingFromCache() 返回 true，Glide 会尝试从磁盘缓存解码图片。本文关注的重点是图片加载的基本流程，怎么从无到有加载一张图片，我们来看下 decodeFromSource() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Resource&lt;?&gt; decodeFromSource() throws Exception &#123;</span><br><span class="line">    return decodeJob.decodeFromSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里交给 DecodeJob 去处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Resource&lt;Z&gt; decodeFromSource() throws Exception &#123;</span><br><span class="line">    ///返回Resource&lt;GifBitmapWrapper&gt;</span><br><span class="line">    Resource&lt;T&gt; decoded = decodeSource();</span><br><span class="line">    ///返回了Resource&lt;GlideDrawable&gt;,统一了静态图和动图类型</span><br><span class="line">    return transformEncodeAndTranscode(decoded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>decodeFromSource() 方法的工作分为两部分：从数据源获取图片，返回封装类 Resource；转化和转码。虽然看似简单，但是每一步都包含大量的逻辑。先看看 decodeSource()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Resource&lt;T&gt; decodeSource() throws Exception &#123;</span><br><span class="line">    Resource&lt;T&gt; decoded = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        long startTime = LogTime.getLogTime();</span><br><span class="line">        ///ImageVideoFetcher,返回一个ImageVideoWrapper</span><br><span class="line">        final A data = fetcher.loadData(priority);</span><br><span class="line">        if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(&quot;Fetched data&quot;, startTime);</span><br><span class="line">        &#125;</span><br><span class="line">        if (isCancelled) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ///返回 Resource&lt;GifBitmapWrapper&gt;</span><br><span class="line">        decoded = decodeFromSourceData(data);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        fetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    return decoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先使用 DataFetcher 的 loadData() 获取图片的原始数据，InputStream 或者是 ParcelFileDescriptor。然后调用 decodeFromSourceData(）进行解码。这里的 DataFetcher 实例其实就是 FixLoaderProvider 提供的 ModelLoader 所提供的 DataFetcher 实例，实际上是 ImageVideoFetcher 类型，我们看看它的 loadData() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static class ImageVideoFetcher implements DataFetcher&lt;ImageVideoWrapper&gt; &#123;</span><br><span class="line">        private final DataFetcher&lt;InputStream&gt; streamFetcher;</span><br><span class="line">        private final DataFetcher&lt;ParcelFileDescriptor&gt; fileDescriptorFetcher;</span><br><span class="line"></span><br><span class="line">        public ImageVideoFetcher(DataFetcher&lt;InputStream&gt; streamFetcher,</span><br><span class="line">                DataFetcher&lt;ParcelFileDescriptor&gt; fileDescriptorFetcher) &#123;</span><br><span class="line">            this.streamFetcher = streamFetcher;</span><br><span class="line">            this.fileDescriptorFetcher = fileDescriptorFetcher;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;resource&quot;)</span><br><span class="line">        // @see ModelLoader.loadData</span><br><span class="line">        @Override</span><br><span class="line">        public ImageVideoWrapper loadData(Priority priority) throws Exception &#123;</span><br><span class="line">            InputStream is = null;</span><br><span class="line">            if (streamFetcher != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ///HttpUrlFetcher</span><br><span class="line">                    is = streamFetcher.loadData(priority);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                        Log.v(TAG, &quot;Exception fetching input stream, trying ParcelFileDescriptor&quot;, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (fileDescriptorFetcher == null) &#123;</span><br><span class="line">                        throw e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ParcelFileDescriptor fileDescriptor = null;</span><br><span class="line">            if (fileDescriptorFetcher != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fileDescriptor = fileDescriptorFetcher.loadData(priority);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                        Log.v(TAG, &quot;Exception fetching ParcelFileDescriptor&quot;, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (is == null) &#123;</span><br><span class="line">                        throw e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ///用来封装服务器返回的InputStream</span><br><span class="line">            return new ImageVideoWrapper(is, fileDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ImageVideoFetcher 内部的 streamFetcher 实际上是一个 HttpUrlFetcher 对象，调用了它的 loadData() 获取 InputStream</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class HttpUrlFetcher implements DataFetcher&lt;InputStream&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public InputStream loadData(Priority priority) throws Exception &#123;</span><br><span class="line">        return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map&lt;String, String&gt; headers)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        if (redirects &gt;= MAXIMUM_REDIRECTS) &#123;</span><br><span class="line">            throw new IOException(&quot;Too many (&gt; &quot; + MAXIMUM_REDIRECTS + &quot;) redirects!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Comparing the URLs using .equals performs additional network I/O and is generally broken.</span><br><span class="line">            // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.</span><br><span class="line">            try &#123;</span><br><span class="line">                if (lastUrl != null &amp;&amp; url.toURI().equals(lastUrl.toURI())) &#123;</span><br><span class="line">                    throw new IOException(&quot;In re-direct loop&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (URISyntaxException e) &#123;</span><br><span class="line">                // Do nothing, this is best effort.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        urlConnection = connectionFactory.build(url);</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123;</span><br><span class="line">          urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        urlConnection.setConnectTimeout(2500);</span><br><span class="line">        urlConnection.setReadTimeout(2500);</span><br><span class="line">        urlConnection.setUseCaches(false);</span><br><span class="line">        urlConnection.setDoInput(true);</span><br><span class="line"></span><br><span class="line">        // Connect explicitly to avoid errors in decoders if connection fails.</span><br><span class="line">        urlConnection.connect();</span><br><span class="line">        if (isCancelled) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        final int statusCode = urlConnection.getResponseCode();</span><br><span class="line">        if (statusCode / 100 == 2) &#123;</span><br><span class="line">            return getStreamForSuccessfulRequest(urlConnection);</span><br><span class="line">        &#125; else if (statusCode / 100 == 3) &#123;</span><br><span class="line">            String redirectUrlString = urlConnection.getHeaderField(&quot;Location&quot;);</span><br><span class="line">            if (TextUtils.isEmpty(redirectUrlString)) &#123;</span><br><span class="line">                throw new IOException(&quot;Received empty or null redirect url&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            URL redirectUrl = new URL(url, redirectUrlString);</span><br><span class="line">            return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (statusCode == -1) &#123;</span><br><span class="line">                throw new IOException(&quot;Unable to retrieve response code from HttpUrlConnection.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new IOException(&quot;Request failed &quot; + statusCode + &quot;: &quot; + urlConnection.getResponseMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        if (TextUtils.isEmpty(urlConnection.getContentEncoding())) &#123;</span><br><span class="line">            int contentLength = urlConnection.getContentLength();</span><br><span class="line">            stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">                Log.d(TAG, &quot;Got non empty content encoding: &quot; + urlConnection.getContentEncoding());</span><br><span class="line">            &#125;</span><br><span class="line">            stream = urlConnection.getInputStream();</span><br><span class="line">        &#125;</span><br><span class="line">        return stream;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loadData() 方法内部又去调用了 loadDataWithRedirects() 方法，loadDataWithRedirects() 方法内部使用 UrlConnection 获取了从服务器返回的 InputStream。至此，Glide 根据 URL 的字符串向服务器发起请求并成功收到响应，万里长征才算是刚刚完成一半。</p>
<p>回到 loadData() 方法，收到服务器返回的 InputStream 之后，用它来构建一个封装类 ImageVideoWrapper 并返回。继续向上返回到 decodeSource() 方法，接下来调用 decodeFromSourceData() 进行解码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Resource&lt;T&gt; decodeFromSourceData(A data) throws IOException &#123;</span><br><span class="line">    final Resource&lt;T&gt; decoded;</span><br><span class="line">    ///判断磁盘缓存策略中是否缓存 Source,缓存 ImageVideoWrapper 并 decode</span><br><span class="line">    if (diskCacheStrategy.cacheSource()) &#123;</span><br><span class="line">        decoded = cacheAndDecodeSourceData(data);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ///loadProvider就是刚才在onSizeReady()方法中得到的FixedLoadProvider，</span><br><span class="line">        // 而getSourceDecoder()得到的则是一个GifBitmapWrapperResourceDecoder对象,</span><br><span class="line">        // 得到Resource&lt;GifBitmapWrapper&gt;</span><br><span class="line">        long startTime = LogTime.getLogTime();</span><br><span class="line">        decoded = loadProvider.getSourceDecoder().decode(data, width, height);</span><br><span class="line">        if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(&quot;Decoded from source&quot;, startTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return decoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看不进行缓存的分支，loadProvider.getSourceDecoder() 获取一个 SourceDecoder，我们分析过，会得到一个 GifBitmapWrapperResourceDecoder 对象，解码工作交给它来执行，我们看看它的 decode() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public Resource&lt;GifBitmapWrapper&gt; decode(ImageVideoWrapper source, int width, int height) throws IOException &#123;</span><br><span class="line">    ByteArrayPool pool = ByteArrayPool.get();</span><br><span class="line">    byte[] tempBytes = pool.getBytes();</span><br><span class="line"></span><br><span class="line">    GifBitmapWrapper wrapper = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        wrapper = decode(source, width, height, tempBytes);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        pool.releaseBytes(tempBytes);</span><br><span class="line">    &#125;</span><br><span class="line">    return wrapper != null ? new GifBitmapWrapperResource(wrapper) : null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private GifBitmapWrapper decode(ImageVideoWrapper source, int width, int height, byte[] bytes) throws IOException &#123;</span><br><span class="line">    final GifBitmapWrapper result;</span><br><span class="line">    if (source.getStream() != null) &#123;</span><br><span class="line">        ///准备从服务器返回的流当中读取数据</span><br><span class="line">        result = decodeStream(source, width, height, bytes);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result = decodeBitmapWrapper(source, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///decodeStream()方法中会先从流中读取2个字节的数据，来判断这张图是GIF图还是普通的静图，</span><br><span class="line">// 如果是GIF图就调用decodeGifWrapper()方法来进行解码，如果是普通的静图就用调用decodeBitmapWrapper()方法来进行解码</span><br><span class="line">private GifBitmapWrapper decodeStream(ImageVideoWrapper source, int width, int height, byte[] bytes)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    InputStream bis = streamFactory.build(source.getStream(), bytes);</span><br><span class="line">    bis.mark(MARK_LIMIT_BYTES);</span><br><span class="line">    ImageHeaderParser.ImageType type = parser.parse(bis);</span><br><span class="line">    bis.reset();</span><br><span class="line"></span><br><span class="line">    GifBitmapWrapper result = null;</span><br><span class="line">    if (type == ImageHeaderParser.ImageType.GIF) &#123;</span><br><span class="line">        result = decodeGifWrapper(bis, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    // Decoding the gif may fail even if the type matches.</span><br><span class="line">    if (result == null) &#123;</span><br><span class="line">        // We can only reset the buffered InputStream, so to start from the beginning of the stream, we need to</span><br><span class="line">        // pass in a new source containing the buffered stream rather than the original stream.</span><br><span class="line">        ImageVideoWrapper forBitmapDecoder = new ImageVideoWrapper(bis, source.getFileDescriptor());</span><br><span class="line">        result = decodeBitmapWrapper(forBitmapDecoder, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private GifBitmapWrapper decodeBitmapWrapper(ImageVideoWrapper toDecode, int width, int height) throws IOException &#123;</span><br><span class="line">    GifBitmapWrapper result = null;</span><br><span class="line"></span><br><span class="line">    ///这个bitmapDecoder是一个ImageVideoBitmapDecoder对象.将InputStream或者ParcelFileDescriptor转换成bitmap</span><br><span class="line">    Resource&lt;Bitmap&gt; bitmapResource = bitmapDecoder.decode(toDecode, width, height);</span><br><span class="line">    if (bitmapResource != null) &#123;</span><br><span class="line">        result = new GifBitmapWrapper(bitmapResource, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private GifBitmapWrapper decodeGifWrapper(InputStream bis, int width, int height) throws IOException &#123;</span><br><span class="line">    GifBitmapWrapper result = null;</span><br><span class="line">    ///GifResourceDecoder</span><br><span class="line">    Resource&lt;GifDrawable&gt; gifResource = gifDecoder.decode(bis, width, height);</span><br><span class="line">    if (gifResource != null) &#123;</span><br><span class="line">        GifDrawable drawable = gifResource.get();</span><br><span class="line">        // We can more efficiently hold Bitmaps in memory, so for static GIFs, try to return Bitmaps</span><br><span class="line">        // instead. Returning a Bitmap incurs the cost of allocating the GifDrawable as well as the normal</span><br><span class="line">        // Bitmap allocation, but since we can encode the Bitmap out as a JPEG, future decodes will be</span><br><span class="line">        // efficient.</span><br><span class="line">        if (drawable.getFrameCount() &gt; 1) &#123;</span><br><span class="line">            result = new GifBitmapWrapper(null /*bitmapResource*/, gifResource);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Resource&lt;Bitmap&gt; bitmapResource = new BitmapResource(drawable.getFirstFrame(), bitmapPool);</span><br><span class="line">            result = new GifBitmapWrapper(bitmapResource, null /*gifResource*/);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>decode() 方法内部调用了重载的 decode() 方法，其内部调用了 decodeStream() 将 InputStream 解码成图片。</p>
<p>decodeStream() 方法中会从流中读取2个字节的数据来判断这张图是 Gif 还是普通的静图，如果是 Gif 图则调用 decodeGifWrapper() 方法来进行解码，如果是普通的静图就用调用 decodeBitmapWrapper() 方法来进行解码。这里选取比较常见的静图解码来分析。</p>
<p>decodeBitmapWrapper() 方法内部调用 bitmapDecoder 对象的 decode() 方法，然后封装成一个GifBitmapWrapper。bitmapDecoder 实际上是一个 ImageVideoBitmapDecoder 对象，来看一下它的 decode() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ImageVideoBitmapDecoder implements ResourceDecoder&lt;ImageVideoWrapper, Bitmap&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;resource&quot;)</span><br><span class="line">    // @see ResourceDecoder.decode</span><br><span class="line">    @Override</span><br><span class="line">    public Resource&lt;Bitmap&gt; decode(ImageVideoWrapper source, int width, int height) throws IOException &#123;</span><br><span class="line">        Resource&lt;Bitmap&gt; result = null;</span><br><span class="line">        InputStream is = source.getStream();</span><br><span class="line">        if (is != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ///streamDecode是一个StreamBitmapDecoder对象</span><br><span class="line">                result = streamDecoder.decode(is, width, height);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                    Log.v(TAG, &quot;Failed to load image from stream, trying FileDescriptor&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (result == null) &#123;</span><br><span class="line">            ParcelFileDescriptor fileDescriptor = source.getFileDescriptor();</span><br><span class="line">            if (fileDescriptor != null) &#123;</span><br><span class="line">                result = fileDescriptorDecoder.decode(fileDescriptor, width, height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ImageVideoBitmapDecoder 的 decode() 方法内部又将解码工作交给了 StreamBitmapDecoder 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">===StreamBitmapDecoder.java===</span><br><span class="line"></span><br><span class="line">public class StreamBitmapDecoder implements ResourceDecoder&lt;InputStream, Bitmap&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Resource&lt;Bitmap&gt; decode(InputStream source, int width, int height) &#123;</span><br><span class="line">        Bitmap bitmap = downsampler.decode(source, bitmapPool, width, height, decodeFormat);</span><br><span class="line">        return BitmapResource.obtain(bitmap, bitmapPool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===Downsampler.java===</span><br><span class="line"></span><br><span class="line">public Bitmap decode(InputStream is, BitmapPool pool, int outWidth, int outHeight, DecodeFormat decodeFormat) &#123;</span><br><span class="line">        final ByteArrayPool byteArrayPool = ByteArrayPool.get();</span><br><span class="line">        final byte[] bytesForOptions = byteArrayPool.getBytes();</span><br><span class="line">        final byte[] bytesForStream = byteArrayPool.getBytes();</span><br><span class="line">        final BitmapFactory.Options options = getDefaultOptions();</span><br><span class="line"></span><br><span class="line">        // Use to fix the mark limit to avoid allocating buffers that fit entire images.</span><br><span class="line">        RecyclableBufferedInputStream bufferedStream = new RecyclableBufferedInputStream(</span><br><span class="line">                is, bytesForStream);</span><br><span class="line">        // Use to retrieve exceptions thrown while reading.</span><br><span class="line">        // TODO(#126): when the framework no longer returns partially decoded Bitmaps or provides a way to determine</span><br><span class="line">        // if a Bitmap is partially decoded, consider removing.</span><br><span class="line">        ExceptionCatchingInputStream exceptionStream =</span><br><span class="line">                ExceptionCatchingInputStream.obtain(bufferedStream);</span><br><span class="line">        // Use to read data.</span><br><span class="line">        // Ensures that we can always reset after reading an image header so that we can still attempt to decode the</span><br><span class="line">        // full image even when the header decode fails and/or overflows our read buffer. See #283.</span><br><span class="line">        MarkEnforcingInputStream invalidatingStream = new MarkEnforcingInputStream(exceptionStream);</span><br><span class="line">        try &#123;</span><br><span class="line">            exceptionStream.mark(MARK_POSITION);</span><br><span class="line">            int orientation = 0;</span><br><span class="line">            try &#123;</span><br><span class="line">                orientation = new ImageHeaderParser(exceptionStream).getOrientation();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                if (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">                    Log.w(TAG, &quot;Cannot determine the image orientation from header&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    exceptionStream.reset();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    if (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">                        Log.w(TAG, &quot;Cannot reset the input stream&quot;, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            options.inTempStorage = bytesForOptions;</span><br><span class="line"></span><br><span class="line">            ///编码过程中通过设置采样率缩放图片，降低内存占用，提高加载性能。</span><br><span class="line">            final int[] inDimens = getDimensions(invalidatingStream, bufferedStream, options);</span><br><span class="line">            final int inWidth = inDimens[0];</span><br><span class="line">            final int inHeight = inDimens[1];</span><br><span class="line"></span><br><span class="line">            final int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);</span><br><span class="line">            final int sampleSize = getRoundedSampleSize(degreesToRotate, inWidth, inHeight, outWidth, outHeight);</span><br><span class="line"></span><br><span class="line">            final Bitmap downsampled =</span><br><span class="line">                    downsampleWithSize(invalidatingStream, bufferedStream, options, pool, inWidth, inHeight, sampleSize,</span><br><span class="line">                            decodeFormat);</span><br><span class="line"></span><br><span class="line">            // BitmapFactory swallows exceptions during decodes and in some cases when inBitmap is non null, may catch</span><br><span class="line">            // and log a stack trace but still return a non null bitmap. To avoid displaying partially decoded bitmaps,</span><br><span class="line">            // we catch exceptions reading from the stream in our ExceptionCatchingInputStream and throw them here.</span><br><span class="line">            final Exception streamException = exceptionStream.getException();</span><br><span class="line">            if (streamException != null) &#123;</span><br><span class="line">                throw new RuntimeException(streamException);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Bitmap rotated = null;</span><br><span class="line">            if (downsampled != null) &#123;</span><br><span class="line">                rotated = TransformationUtils.rotateImageExif(downsampled, pool, orientation);</span><br><span class="line"></span><br><span class="line">                if (!downsampled.equals(rotated) &amp;&amp; !pool.put(downsampled)) &#123;</span><br><span class="line">                    downsampled.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return rotated;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            byteArrayPool.releaseBytes(bytesForOptions);</span><br><span class="line">            byteArrayPool.releaseBytes(bytesForStream);</span><br><span class="line">            exceptionStream.release();</span><br><span class="line">            releaseOptions(options);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>经过层层跋涉，可以看到最终的解码工作就在 Downsampler 的 decode() 方法这里了。里面包含很多的逻辑，包括对图片的压缩，甚至还有旋转、圆角等逻辑处理。总之，decode() 最终返回了一个 Bitmap 对象。然后向上层层返回，在 StreamBitmapDecoder 的 decode() 方法中 Bitmap 被封装成 Resource\<bitmap\> 对象。在 GifBitmapWrapperResourceDecoder 的 decodeBitmapWrapper() 方法中Resource\<bitmap\> 进而被封装成 GifBitmapWrapper 对象。最后在 GifBitmapWrapperResourceDecoder 的 decode() 方法中封装成 Resource\<gifbitmapwrapper\> 对象。</gifbitmapwrapper\></bitmap\></bitmap\></p>
<p>有点混乱，这里用图表整理一下</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">返回值</th>
<th style="text-align:center">封装内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GifBitmapWrapperResourceDecoder.decode()</td>
<td style="text-align:center">Resource\<gifbitmapwrapper\></gifbitmapwrapper\></td>
<td style="text-align:center">GifBitmapWrapper</td>
</tr>
<tr>
<td style="text-align:center">GifBitmapWrapperResourceDecoder.decodeBitmapWrapper()</td>
<td style="text-align:center">GifBitmapWrapper</td>
<td style="text-align:center">Resource\<gifdrawable\>和Resource\<bitmap\></bitmap\></gifdrawable\></td>
</tr>
<tr>
<td style="text-align:center">StreamBitmapDecoder.decode()</td>
<td style="text-align:center">Resource\<bitmap\></bitmap\></td>
<td style="text-align:center">Bitmap</td>
</tr>
<tr>
<td style="text-align:center">Downsampler.decode()</td>
<td style="text-align:center">Bitmap</td>
</tr>
</tbody>
</table>
<p>可以看到，不管加载的是静图还是Gif动图，都能通过返回 Resource\<gifbitmapwrapper\> 对象来表示</gifbitmapwrapper\></p>
<p>最后经过千辛万苦，返回到了 DecodeJob 的 decodeFromSource() 方法中，得到 Resource\<gifbitmapwrapper\> 对象，解码工作完成。</gifbitmapwrapper\></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Resource&lt;Z&gt; decodeFromSource() throws Exception &#123;</span><br><span class="line">     ///返回Resource&lt;GifBitmapWrapper&gt;</span><br><span class="line">     Resource&lt;T&gt; decoded = decodeSource();</span><br><span class="line">     ///返回了Resource&lt;GlideDrawable&gt;,统一了静态图和动图类型</span><br><span class="line">     return transformEncodeAndTranscode(decoded);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是转化和转码的工作了，来看下 transformEncodeAndTranscode() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Resource&lt;Z&gt; transformEncodeAndTranscode(Resource&lt;T&gt; decoded) &#123;</span><br><span class="line">     long startTime = LogTime.getLogTime();</span><br><span class="line">     Resource&lt;T&gt; transformed = transform(decoded);</span><br><span class="line">     if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">         logWithTimeAndKey(&quot;Transformed resource from source&quot;, startTime);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ///将transform后的resource写入缓存</span><br><span class="line">     writeTransformedToCache(transformed);</span><br><span class="line"></span><br><span class="line">     startTime = LogTime.getLogTime();</span><br><span class="line">     ///返回了Resource&lt;GlideDrawable&gt;</span><br><span class="line">     Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class="line">     if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">         logWithTimeAndKey(&quot;Transcoded transformed from source&quot;, startTime);</span><br><span class="line">     &#125;</span><br><span class="line">     return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>同样写入缓存的部分略过，transformEncodeAndTranscode() 的主要工作包括两部分，调用 transform() 方法进行图片的变换，然后调用 transcode() 方法进行转码。先来看下 transform() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Resource&lt;T&gt; transform(Resource&lt;T&gt; decoded) &#123;</span><br><span class="line">    if (decoded == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ///GenericRequestBuilder.into中根据imageview的scaletype保存了transformation,</span><br><span class="line">    // 比如是drawable的centercrop那么transformation就是GifBitmapWrapperTransformation(内部封装类型为CenterCrop的BitmapTransformation对象)</span><br><span class="line">    Resource&lt;T&gt; transformed = transformation.transform(decoded, width, height);</span><br><span class="line">    if (!decoded.equals(transformed)) &#123;</span><br><span class="line">        decoded.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    return transformed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法内部调用了 transformation 对象的 transform 来执行图片变换。还记得 GenericRequestBuilder 的 into() 方法么？当时就判断了 ImageView 的 ScaleType,将对应的 Transformation 实例保存在 transformation，这里的 transformation 对象实际上就是由 GenericRequestBuilder 传过来的。</p>
<p>假设当前 ImageView 的 ScaleType 是 CenterCrop，那么得到 transformation 对象就是 GifBitmapWrapperTransformation，其内部封装了用于 Bitmap 变换 的 Transformation 实例 CenterCrop 对象，还有用于 GifDrawable 变换的 Transformation 实例 GifDrawableTransformation 对象。</p>
<p>那么我们看看 GifBitmapWrapperTransformation 的 transform() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class GifBitmapWrapperTransformation implements Transformation&lt;GifBitmapWrapper&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public GifBitmapWrapperTransformation(BitmapPool bitmapPool, Transformation&lt;Bitmap&gt; bitmapTransformation) &#123;</span><br><span class="line">        this(bitmapTransformation, new GifDrawableTransformation(bitmapTransformation, bitmapPool));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GifBitmapWrapperTransformation(Transformation&lt;Bitmap&gt; bitmapTransformation,</span><br><span class="line">            Transformation&lt;GifDrawable&gt; gifDataTransformation) &#123;</span><br><span class="line">        this.bitmapTransformation = bitmapTransformation;</span><br><span class="line">        this.gifDataTransformation = gifDataTransformation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Resource&lt;GifBitmapWrapper&gt; transform(Resource&lt;GifBitmapWrapper&gt; resource, int outWidth, int outHeight) &#123;</span><br><span class="line">        Resource&lt;Bitmap&gt; bitmapResource = resource.get().getBitmapResource();</span><br><span class="line">        Resource&lt;GifDrawable&gt; gifResource = resource.get().getGifResource();</span><br><span class="line">        if (bitmapResource != null &amp;&amp; bitmapTransformation != null) &#123;</span><br><span class="line">            ///FitCenter 或 CenterCrop</span><br><span class="line">            Resource&lt;Bitmap&gt; transformed = bitmapTransformation.transform(bitmapResource, outWidth, outHeight);</span><br><span class="line">            if (!bitmapResource.equals(transformed)) &#123;</span><br><span class="line">                GifBitmapWrapper gifBitmap = new GifBitmapWrapper(transformed, resource.get().getGifResource());</span><br><span class="line">                return new GifBitmapWrapperResource(gifBitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (gifResource != null &amp;&amp; gifDataTransformation != null) &#123;</span><br><span class="line">            Resource&lt;GifDrawable&gt; transformed = gifDataTransformation.transform(gifResource, outWidth, outHeight);</span><br><span class="line">            if (!gifResource.equals(transformed)) &#123;</span><br><span class="line">                GifBitmapWrapper gifBitmap = new GifBitmapWrapper(resource.get().getBitmapResource(), transformed);</span><br><span class="line">                return new GifBitmapWrapperResource(gifBitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GifBitmapWrapperTransformation 是一个 Transformation\<gifbitmapwrapper\>，它变换的对象是 GifBitmapWrapper，自然也就需要执行 Bitmap 或者 GifDrawable 的变换。首先判断 GifBitmapWrapper 中封装的是静图 Bitmap 还是 动图 Gif，然后再交给对应的 Transformation 实例做变换。如果 ImageView 的 ScaleType 是 CenterCrop，那么此处的 bitmapTransformation 就是 CenterCrop 对象，那么我们来看看 CenterCrop 的 transform() 方法</gifbitmapwrapper\></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CenterCrop extends BitmapTransformation &#123;</span><br><span class="line"></span><br><span class="line">    // Bitmap doesn&apos;t implement equals, so == and .equals are equivalent here.</span><br><span class="line">    @SuppressWarnings(&quot;PMD.CompareObjectsWithEquals&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123;</span><br><span class="line">        ///从 BitmapPool 中获取可复用的 Bitmap</span><br><span class="line">        final Bitmap toReuse = pool.get(outWidth, outHeight, toTransform.getConfig() != null</span><br><span class="line">                ? toTransform.getConfig() : Bitmap.Config.ARGB_8888);</span><br><span class="line">        Bitmap transformed = TransformationUtils.centerCrop(toReuse, toTransform, outWidth, outHeight);</span><br><span class="line">        if (toReuse != null &amp;&amp; toReuse != transformed &amp;&amp; !pool.put(toReuse)) &#123;</span><br><span class="line">            toReuse.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        return transformed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transform() 方法最终调用了 TransformationUtils 的静态方法 centerCrop() 去处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) &#123;</span><br><span class="line">        if (toCrop == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else if (toCrop.getWidth() == width &amp;&amp; toCrop.getHeight() == height) &#123;</span><br><span class="line">            return toCrop;</span><br><span class="line">        &#125;</span><br><span class="line">        // From ImageView/Bitmap.createScaledBitmap.</span><br><span class="line">        final float scale;</span><br><span class="line">        float dx = 0, dy = 0;</span><br><span class="line">        Matrix m = new Matrix();</span><br><span class="line">        if (toCrop.getWidth() * height &gt; width * toCrop.getHeight()) &#123;</span><br><span class="line">            scale = (float) height / (float) toCrop.getHeight();</span><br><span class="line">            dx = (width - toCrop.getWidth() * scale) * 0.5f;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            scale = (float) width / (float) toCrop.getWidth();</span><br><span class="line">            dy = (height - toCrop.getHeight() * scale) * 0.5f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m.setScale(scale, scale);</span><br><span class="line">        m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));</span><br><span class="line">        final Bitmap result;</span><br><span class="line">        if (recycled != null) &#123;</span><br><span class="line">            result = recycled;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = Bitmap.createBitmap(width, height, getSafeConfig(toCrop));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We don&apos;t add or remove alpha, so keep the alpha setting of the Bitmap we were given.</span><br><span class="line">        TransformationUtils.setAlpha(toCrop, result);</span><br><span class="line"></span><br><span class="line">        Canvas canvas = new Canvas(result);</span><br><span class="line">        Paint paint = new Paint(PAINT_FLAGS);</span><br><span class="line">        canvas.drawBitmap(toCrop, m, paint);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>centerCrop() 方法就是根据给定的宽和高来缩放 toCrop Bitmap，使得 bitmap 的其中一边与给定宽高相等，而另一边较长，然后进行截取。那么经过 centerCrop() 方法处理，我们就得到了一个经过变换的 Bitmap。一直向上返回，一直回到 transformEncodeAndTranscode() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Resource&lt;Z&gt; transformEncodeAndTranscode(Resource&lt;T&gt; decoded) &#123;</span><br><span class="line">     long startTime = LogTime.getLogTime();</span><br><span class="line">     Resource&lt;T&gt; transformed = transform(decoded);</span><br><span class="line">     if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">         logWithTimeAndKey(&quot;Transformed resource from source&quot;, startTime);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ///将transform后的resource写入缓存</span><br><span class="line">     writeTransformedToCache(transformed);</span><br><span class="line"></span><br><span class="line">     startTime = LogTime.getLogTime();</span><br><span class="line">     ///返回了Resource&lt;GlideDrawable&gt;</span><br><span class="line">     Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class="line">     if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">         logWithTimeAndKey(&quot;Transcoded transformed from source&quot;, startTime);</span><br><span class="line">     &#125;</span><br><span class="line">     return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>transformEncodeAndTranscode() 方法的工作已经完成一半，目前我们得到的还是 Resource\<gifbitmapwrapper\> 对象，只不过 其中封装的 Resource\<bitmap\> 已经根据 ScaleType 进行了变换。</bitmap\></gifbitmapwrapper\></p>
<p>然后转码的功过就是在  transcode(）方法内部了，要注意的是它将返回的是 Resource\<glidedrawable\> 对象</glidedrawable\></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Resource&lt;Z&gt; transcode(Resource&lt;T&gt; transformed) &#123;</span><br><span class="line">        if (transformed == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ///GifBitmapWrapperDrawableTranscoder</span><br><span class="line">        return transcoder.transcode(transformed);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法内部又调用了 transcoder 的 transcode() 方法。这里的 transcoder 是什么呢？让我们追本溯源，发现答案就在 DrawableRequestBuilder 的构造函数。</p>
<p>当时在 DrawableRequestBuilder 的构造函数中创建了一个 FixedLoadProvider 对象，创建 FixedLoadProvider 对象的时候，在它的构造函数里传了一个 GifBitmapWrapperDrawableTranscoder 对象，后来这个 GifBitmapWrapperDrawableTranscoder 不远千里，途经 GenericRequest、Engine 来到 DecodeJob。所以 transcoder 就是 GifBitmapWrapperDrawableTranscoder 对象。</p>
<p>那么我们看看它的 transcode 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">///GifBitmapWrapperDrawableTranscoder的核心作用就是用来转码的。</span><br><span class="line">// 因为GifBitmapWrapper是无法直接显示到ImageView上面的，只有Bitmap或者Drawable才能显示到ImageView上。</span><br><span class="line">// 因此，这里的transcode()方法先从Resource&lt;GifBitmapWrapper&gt;中取出GifBitmapWrapper对象，然后再从GifBitmapWrapper中取出Resource&lt;Bitmap&gt;对象。</span><br><span class="line">public class GifBitmapWrapperDrawableTranscoder implements ResourceTranscoder&lt;GifBitmapWrapper, GlideDrawable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ///转码之后,因为不管是静图的Resource&lt;GlideBitmapDrawable&gt;对象，</span><br><span class="line">    // 还是动图的Resource&lt;GifDrawable&gt;对象，它们都是属于父类Resource&lt;GlideDrawable&gt;对象的</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public Resource&lt;GlideDrawable&gt; transcode(Resource&lt;GifBitmapWrapper&gt; toTranscode) &#123;</span><br><span class="line">        GifBitmapWrapper gifBitmap = toTranscode.get();</span><br><span class="line">        Resource&lt;Bitmap&gt; bitmapResource = gifBitmap.getBitmapResource();</span><br><span class="line"></span><br><span class="line">        final Resource&lt;? extends GlideDrawable&gt; result;</span><br><span class="line">        if (bitmapResource != null) &#123;</span><br><span class="line">            ///说明加载的是bitmap,需要再做一次转码，将Bitmap转换成Drawable对象.因为要保证静图和动图的类型一致性，不然逻辑上是不好处理的。</span><br><span class="line">            ///使用GlideBitmapDrawableTranscoder将bitmap转化成Resource&lt;GlideBitmapDrawable&gt;</span><br><span class="line">            result = bitmapDrawableResourceTranscoder.transcode(bitmapResource);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ///说明此时加载的是GIF图.因为Glide用于加载GIF图片是使用的GifDrawable这个类，它本身就是一个Drawable对象了</span><br><span class="line">            result = gifBitmap.getGifResource();</span><br><span class="line">        &#125;</span><br><span class="line">        // This is unchecked but always safe, anything that extends a Drawable can be safely cast to a Drawable.</span><br><span class="line">        return (Resource&lt;GlideDrawable&gt;) result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转码的目的是为了统一静图和动图 Gif 的类型，是它们都属于 Drawable 类型，以便统一处理逻辑。Glide 中 Gif 动图用 GifDrawable 表示，本身就是 Drawable 的子类，所以不需要转码。而静图 Bitmap 则需要转码为 Drawable。</p>
<p>程序先从 Resource\<gifbitmapwrapper\> 取出 GifBitmapWrapper，然后在 GifBitmapWrapper 中取出 Resource\<bitmap\>。对于 Bitmap 的转码，在 transcode() 方法中交给了 bitmapDrawableResourceTranscoder 处理，bitmapDrawableResourceTranscoder 是一个 GlideBitmapDrawableTranscoder 对象，下面看看它的 transcode() 方法</bitmap\></gifbitmapwrapper\></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class GlideBitmapDrawableTranscoder implements ResourceTranscoder&lt;Bitmap, GlideBitmapDrawable&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Resource&lt;GlideBitmapDrawable&gt; transcode(Resource&lt;Bitmap&gt; toTranscode) &#123;</span><br><span class="line">        GlideBitmapDrawable drawable = new GlideBitmapDrawable(resources, toTranscode.get());</span><br><span class="line">        return new GlideBitmapDrawableResource(drawable, bitmapPool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 创建了一个 GlideBitmapDrawable，然后把 Bitmap 封装到里面，然后对 GlideBitmapDrawable 再一次封装，返回一个 Resource\<glidebitmapdrawable\> 对象。</glidebitmapdrawable\></p>
<p>现在不管是静图 Resource\<glidebitmapdrawable\> 还是动图 Resource\<gifdrawable\> ，它们都属于父类Resource\<glidedrawable\>对象。</glidedrawable\></gifdrawable\></glidebitmapdrawable\></p>
<p>那么现在转码的工作也已经完成了，只剩下将图片显示出来的工作了。从 DecodeJob 的 transformEncodeAndTranscode() 方法开始向上返回，一直返回到 EngineRunnable 的 run() 方法，我们重新看一下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void run() &#123;</span><br><span class="line">     if (isCancelled) &#123;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Exception exception = null;</span><br><span class="line">     Resource&lt;?&gt; resource = null;</span><br><span class="line">     try &#123;</span><br><span class="line">         ///得到了Resource&lt;GlideDrawable&gt;对象</span><br><span class="line">         resource = decode();</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">             Log.v(TAG, &quot;Exception decoding&quot;, e);</span><br><span class="line">         &#125;</span><br><span class="line">         exception = e;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (isCancelled) &#123;</span><br><span class="line">         if (resource != null) &#123;</span><br><span class="line">             resource.recycle();</span><br><span class="line">         &#125;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (resource == null) &#123;</span><br><span class="line">         /// 第一次走decode()尝试从磁盘获取,失败后会走这里。重新进入decode</span><br><span class="line">         onLoadFailed(exception);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         onLoadComplete(resource);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上次我们从 decode() 方法开始追溯，经过向服务发送请求，接收 InputStream，将 InputStream 解码成 Bitmap 或者 GifDrawable，然后经过 ScaleType 变换，转码 的一系列复杂逻辑，现在终于从 decode() 方法出来了，真是恍如隔世，现在我们拥有了 Resource\<glidedrawable\>对象，准备将图片显示出来。</glidedrawable\></p>
<p>显然接下来就是调用 onLoadComplete() 方法了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void onLoadComplete(Resource resource) &#123;</span><br><span class="line">     ///manager就是EngineJob对象</span><br><span class="line">     manager.onResourceReady(resource);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>只有简单的一行代码，这个 manager 实际上是 EngineJob 对象，上次提到它是负责统一管理加载请求的 onResourceReady() 回调的，那么我们来看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">class EngineJob implements EngineRunnable.EngineRunnableManager &#123;</span><br><span class="line">    private static final Handler MAIN_THREAD_HANDLER = new Handler(Looper.getMainLooper(), new MainThreadCallback());</span><br><span class="line">    </span><br><span class="line">    public void addCallback(ResourceCallback cb) &#123;</span><br><span class="line">        Util.assertMainThread();</span><br><span class="line">        if (hasResource) &#123;</span><br><span class="line">            cb.onResourceReady(engineResource);</span><br><span class="line">        &#125; else if (hasException) &#123;</span><br><span class="line">            cb.onException(exception);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cbs.add(cb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onResourceReady(final Resource&lt;?&gt; resource) &#123;</span><br><span class="line">        this.resource = resource;</span><br><span class="line">        ///使用Handler发出了一条MSG_COMPLETE消息，那么在MainThreadCallback的handleMessage()方法中就会收到这条消息。</span><br><span class="line">        // 从这里开始，所有的逻辑又回到主线程当中进行了</span><br><span class="line">        MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void handleResultOnMainThread() &#123;</span><br><span class="line">        if (isCancelled) &#123;</span><br><span class="line">            resource.recycle();</span><br><span class="line">            return;</span><br><span class="line">        &#125; else if (cbs.isEmpty()) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Received a resource without any callbacks to notify&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        ///封装成一个EngineResource</span><br><span class="line">        engineResource = engineResourceFactory.build(resource, isCacheable);</span><br><span class="line">        hasResource = true;</span><br><span class="line"></span><br><span class="line">        // Hold on to resource for duration of request so we don&apos;t recycle it in the middle of notifying if it</span><br><span class="line">        // synchronously released by one of the callbacks.</span><br><span class="line">        engineResource.acquire();</span><br><span class="line">        ///key是一个EngineKey。如果resource.isCacheable()为true,resource将添加到activeResources中,并在移除时加入到memorycache</span><br><span class="line">        listener.onEngineJobComplete(key, engineResource);</span><br><span class="line"></span><br><span class="line">        ///这里的ResourceCallback就是GenericRequest,由GenericRequest调用EngineJob的load方法时传入</span><br><span class="line">        for (ResourceCallback cb : cbs) &#123;</span><br><span class="line">            if (!isInIgnoredCallbacks(cb)) &#123;</span><br><span class="line">                engineResource.acquire();</span><br><span class="line">                ///回调GenericRequest</span><br><span class="line">                cb.onResourceReady(engineResource);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Our request is complete, so we can release the resource.</span><br><span class="line">        engineResource.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class MainThreadCallback implements Handler.Callback &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean handleMessage(Message message) &#123;</span><br><span class="line">            if (MSG_COMPLETE == message.what || MSG_EXCEPTION == message.what) &#123;</span><br><span class="line">                EngineJob job = (EngineJob) message.obj;</span><br><span class="line">                if (MSG_COMPLETE == message.what) &#123;</span><br><span class="line">                    job.handleResultOnMainThread();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    job.handleExceptionOnMainThread();</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里贴上了相关的代码。在 onResourceReady() 方法中 使用 MAIN_THREAD_HANDLER 发送了一条 MSG_COMPLETE 消息。MAIN_THREAD_HANDLER 是用 Looper.getMainLooper() 构建的一个 Handler 对象，那么 MainThreadCallback 的 handleMessage() 将会在主线程中运行。这一意味着即将要更新 UI 了。</p>
<p>handleResultOnMainThread() 方法中通过循环，遍历了所有 ResourceCallback 的 onResourceReady() 方法。这些 ResourceCallback 都是谁呢？看看谁调用过 EngineJob 的 addCallback() 方法就知道了。其实我们都已经见过了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher,</span><br><span class="line">            DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span><br><span class="line">            Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) &#123;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        EngineJob current = jobs.get(key);</span><br><span class="line">        if (current != null) &#123;</span><br><span class="line">            current.addCallback(cb);</span><br><span class="line">            if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);</span><br><span class="line">            &#125;</span><br><span class="line">            return new LoadStatus(cb, current);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ///EngineJob的主要作用就是用来开启线程的，为后面的异步加载图片做准备</span><br><span class="line">        EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class="line">        DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class="line">                transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class="line">        EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);</span><br><span class="line">        jobs.put(key, engineJob);</span><br><span class="line">        ///将GenericRequest的回调接口交给enginejob</span><br><span class="line">        engineJob.addCallback(cb);</span><br><span class="line">        ///实际上就是让EngineRunnable的run()方法在子线程当中执行了</span><br><span class="line">        engineJob.start(runnable);</span><br><span class="line"></span><br><span class="line">        if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line">        return new LoadStatus(cb, engineJob);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在 Engine 的 load() 方法中，在运行 EngingRunnale 之前，使用 cb 参数调用了 EngineJob 的 addCallback() 方法，以便图片加载完毕之后收到回调。而 cb 就是 GenericRequest 调用 Engine 的 load() 方法时传过来的它自己本身，因为 GenericRequest 本身就实现了 ResourceCallback 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">@Override</span><br><span class="line">public void onResourceReady(Resource&lt;?&gt; resource) &#123;</span><br><span class="line">    if (resource == null) &#123;</span><br><span class="line">        onException(new Exception(&quot;Expected to receive a Resource&lt;R&gt; with an object of &quot; + transcodeClass</span><br><span class="line">                + &quot; inside, but instead got null.&quot;));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ///resource是一个EngineResource,获取到GlideBitmapDrawable 或者是 GifDrawable</span><br><span class="line">    Object received =  resource.get();</span><br><span class="line">    if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) &#123;</span><br><span class="line">        releaseResource(resource);</span><br><span class="line">        onException(new Exception(&quot;Expected to receive an object of &quot; + transcodeClass</span><br><span class="line">                + &quot; but instead got &quot; + (received != null ? received.getClass() : &quot;&quot;) + &quot;&#123;&quot; + received + &quot;&#125;&quot;</span><br><span class="line">                + &quot; inside Resource&#123;&quot; + resource + &quot;&#125;.&quot;</span><br><span class="line">                + (received != null ? &quot;&quot; : &quot; &quot;</span><br><span class="line">                    + &quot;To indicate failure return a null Resource object, &quot;</span><br><span class="line">                    + &quot;rather than a Resource object containing null data.&quot;)</span><br><span class="line">        ));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!canSetResource()) &#123;</span><br><span class="line">        releaseResource(resource);</span><br><span class="line">        // We can&apos;t set the status to complete before asking canSetResource().</span><br><span class="line">        status = Status.COMPLETE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onResourceReady(resource, (R) received);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void onResourceReady(Resource&lt;?&gt; resource, R result) &#123;</span><br><span class="line">    // We must call isFirstReadyResource before setting status.</span><br><span class="line">    boolean isFirstResource = isFirstReadyResource();</span><br><span class="line">    status = Status.COMPLETE;</span><br><span class="line">    this.resource = resource;</span><br><span class="line"></span><br><span class="line">    if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,</span><br><span class="line">            isFirstResource)) &#123;</span><br><span class="line">        GlideAnimation&lt;R&gt; animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);</span><br><span class="line">        ///target就是调用into时构建的GlideDrawableImageViewTarget</span><br><span class="line">        target.onResourceReady(result, animation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notifyLoadSuccess();</span><br><span class="line"></span><br><span class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logV(&quot;Resource ready in &quot; + LogTime.getElapsedMillis(startTime) + &quot; size: &quot;</span><br><span class="line">                + (resource.getSize() * TO_MEGABYTE) + &quot; fromCache: &quot; + loadedFromMemoryCache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有 GenericRequest 中有两个 onResourceReady() 方法，第一个就是 ResourceCallback 接口的方法。该方法中首先调用了 EngineResource 的 get() 方法获取它所封装的 GlideBitmapDrawable 或者是 GifDrawable，然后调用了另一个 onResourceReady() 方法。</p>
<p>在另一个方法中调用了 target 的 onResourceReady() 方法，target 实际上就是我们调用第三步 into() 方法时传的 GlideDrawableImageViewTarget 对象。我们看看它的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class GlideDrawableImageViewTarget extends ImageViewTarget&lt;GlideDrawable&gt; &#123;</span><br><span class="line">    private static final float SQUARE_RATIO_MARGIN = 0.05f;</span><br><span class="line">    private int maxLoopCount;</span><br><span class="line">    private GlideDrawable resource;</span><br><span class="line"></span><br><span class="line">    public GlideDrawableImageViewTarget(ImageView view) &#123;</span><br><span class="line">        this(view, GlideDrawable.LOOP_FOREVER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GlideDrawableImageViewTarget(ImageView view, int maxLoopCount) &#123;</span><br><span class="line">        super(view);</span><br><span class="line">        this.maxLoopCount = maxLoopCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; animation) &#123;</span><br><span class="line">        if (!resource.isAnimated()) &#123;</span><br><span class="line">            float viewRatio = view.getWidth() / (float) view.getHeight();</span><br><span class="line">            float drawableRatio = resource.getIntrinsicWidth() / (float) resource.getIntrinsicHeight();</span><br><span class="line">            if (Math.abs(viewRatio - 1f) &lt;= SQUARE_RATIO_MARGIN</span><br><span class="line">                    &amp;&amp; Math.abs(drawableRatio - 1f) &lt;= SQUARE_RATIO_MARGIN) &#123;</span><br><span class="line">                resource = new SquaringDrawable(resource, view.getWidth());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        super.onResourceReady(resource, animation);</span><br><span class="line">        this.resource = resource;</span><br><span class="line">        resource.setLoopCount(maxLoopCount);</span><br><span class="line">        resource.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sets the drawable on the view using</span><br><span class="line">     * &#123;@link android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param resource The &#123;@link android.graphics.drawable.Drawable&#125; to display in the view.</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void setResource(GlideDrawable resource) &#123;</span><br><span class="line">        view.setImageDrawable(resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">        if (resource != null) &#123;</span><br><span class="line">            resource.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStop() &#123;</span><br><span class="line">        if (resource != null) &#123;</span><br><span class="line">            resource.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GlideDrawableImageViewTarget 的 onResourceReady() 方法中调用了父类的 onResourceReady() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void onResourceReady(Z resource, GlideAnimation&lt;? super Z&gt; glideAnimation) &#123;</span><br><span class="line">    if (glideAnimation == null || !glideAnimation.animate(resource, this)) &#123;</span><br><span class="line">        setResource(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected abstract void setResource(Z resource);</span><br></pre></td></tr></table></figure>
<p>父类的 onResourceReady() 方法调用了子类的 setResource() 实现，回头看一下，GlideDrawableImageViewTarget 的 setResource() 实现 调用了 view.setImageDrawable() 方法，这个 view 就是所封装的 ImageView 对象。图片也就成功显示出来了。</p>
<p>那么，Glide 加载基本流程的源码分析就到此结束。我已经尽力将它描述清楚，希望各位有所收获。</p>
<p>感谢坚持看到这里的你们。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Glide/" rel="tag"># Glide</a>
          
            <a href="/tags/源码分析/" rel="tag"># 源码分析</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/15/听听，一款优雅的开源音乐播放器/" rel="next" title="听听，一款优雅的开源音乐播放器">
                <i class="fa fa-chevron-left"></i> 听听，一款优雅的开源音乐播放器
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/08/Glide源码解析（二）：缓存机制/" rel="prev" title="Glide源码解析（二）：缓存机制">
                Glide源码解析（二）：缓存机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="乌有先生" />
          <p class="site-author-name" itemprop="name">乌有先生</p>
           
              <p class="site-description motion-element" itemprop="description">骑哒哒哒的少年</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hefuyicoder" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#预热"><span class="nav-number">1.</span> <span class="nav-text">预热</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程分析"><span class="nav-number">2.</span> <span class="nav-text">流程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#with"><span class="nav-number">2.1.</span> <span class="nav-text">with</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#load"><span class="nav-number">2.2.</span> <span class="nav-text">load</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#into"><span class="nav-number">2.3.</span> <span class="nav-text">into</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乌有先生</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("gF4sJc4fj0i9CboETGqGQbTp-gzGzoHsz", "VJyTrREXyo0EEnm5AxyEQjKn");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
